// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: schema.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const allSchemas = `-- name: AllSchemas :many
SELECT id, realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby, editedat, editedby FROM public.schema
`

func (q *Queries) AllSchemas(ctx context.Context) ([]Schema, error) {
	rows, err := q.db.Query(ctx, allSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schema
	for rows.Next() {
		var i Schema
		if err := rows.Scan(
			&i.ID,
			&i.Realm,
			&i.Slice,
			&i.App,
			&i.Brwf,
			&i.Class,
			&i.Patternschema,
			&i.Actionschema,
			&i.Createdat,
			&i.Createdby,
			&i.Editedat,
			&i.Editedby,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchemaWithLock = `-- name: GetSchemaWithLock :one
SELECT
    id,
    brwf,
    patternschema,
    actionschema,
    editedat,
    editedby
FROM schema
WHERE
    realm = $4::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id=$1 AND realmslice.realm = $4)
    AND class = $2
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc=$3 AND app.realm = $4) FOR
UPDATE
`

type GetSchemaWithLockParams struct {
	ID          int32  `json:"id"`
	Class       string `json:"class"`
	Shortnamelc string `json:"shortnamelc"`
	RealmName   string `json:"realm_name"`
}

type GetSchemaWithLockRow struct {
	ID            int32            `json:"id"`
	Brwf          BrwfEnum         `json:"brwf"`
	Patternschema []byte           `json:"patternschema"`
	Actionschema  []byte           `json:"actionschema"`
	Editedat      pgtype.Timestamp `json:"editedat"`
	Editedby      pgtype.Text      `json:"editedby"`
}

func (q *Queries) GetSchemaWithLock(ctx context.Context, arg GetSchemaWithLockParams) (GetSchemaWithLockRow, error) {
	row := q.db.QueryRow(ctx, getSchemaWithLock,
		arg.ID,
		arg.Class,
		arg.Shortnamelc,
		arg.RealmName,
	)
	var i GetSchemaWithLockRow
	err := row.Scan(
		&i.ID,
		&i.Brwf,
		&i.Patternschema,
		&i.Actionschema,
		&i.Editedat,
		&i.Editedby,
	)
	return i, err
}

const schemaDelete = `-- name: SchemaDelete :one
DELETE FROM schema WHERE id = $1 RETURNING id
`

func (q *Queries) SchemaDelete(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, schemaDelete, id)
	err := row.Scan(&id)
	return id, err
}

const schemaGet = `-- name: SchemaGet :many
SELECT schema.slice, schema.app, app.longname, schema.class, schema.createdby, schema.createdat, schema.editedby, schema.editedat
FROM schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    schema.realm = $1
    AND schema.slice = $2
    AND schema.class = $3
    AND schema.app = $4
`

type SchemaGetParams struct {
	Realm string `json:"realm"`
	Slice int32  `json:"slice"`
	Class string `json:"class"`
	App   string `json:"app"`
}

type SchemaGetRow struct {
	Slice     int32            `json:"slice"`
	App       string           `json:"app"`
	Longname  string           `json:"longname"`
	Class     string           `json:"class"`
	Createdby string           `json:"createdby"`
	Createdat pgtype.Timestamp `json:"createdat"`
	Editedby  pgtype.Text      `json:"editedby"`
	Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaGet(ctx context.Context, arg SchemaGetParams) ([]SchemaGetRow, error) {
	rows, err := q.db.Query(ctx, schemaGet,
		arg.Realm,
		arg.Slice,
		arg.Class,
		arg.App,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchemaGetRow
	for rows.Next() {
		var i SchemaGetRow
		if err := rows.Scan(
			&i.Slice,
			&i.App,
			&i.Longname,
			&i.Class,
			&i.Createdby,
			&i.Createdat,
			&i.Editedby,
			&i.Editedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schemaNew = `-- name: SchemaNew :one
INSERT INTO
    schema(
        realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby
    )
VALUES (
        $6::varchar, 
        (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $7 AND realmslice.realm = $6 ), 
        (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $8 AND app.realm = $6), 
        $1, $2, $3, $4, CURRENT_TIMESTAMP, $5
    ) RETURNING id
`

type SchemaNewParams struct {
	Brwf          BrwfEnum `json:"brwf"`
	Class         string   `json:"class"`
	Patternschema []byte   `json:"patternschema"`
	Actionschema  []byte   `json:"actionschema"`
	Createdby     string   `json:"createdby"`
	RealmName     string   `json:"realm_name"`
	Slice         int32    `json:"slice"`
	App           string   `json:"app"`
}

func (q *Queries) SchemaNew(ctx context.Context, arg SchemaNewParams) (int32, error) {
	row := q.db.QueryRow(ctx, schemaNew,
		arg.Brwf,
		arg.Class,
		arg.Patternschema,
		arg.Actionschema,
		arg.Createdby,
		arg.RealmName,
		arg.Slice,
		arg.App,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const schemaUpdate = `-- name: SchemaUpdate :exec
UPDATE schema
SET
    brwf = $2,
    patternschema = COALESCE($3,patternschema),
    actionschema = COALESCE($4,actionschema),
    editedat = CURRENT_TIMESTAMP,
    editedby = $5
WHERE
    realm = $6::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id= $7 AND realmslice.realm = $6)
    AND class = $1
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc= $8 AND app.realm = $6)
`

type SchemaUpdateParams struct {
	Class         string      `json:"class"`
	Brwf          BrwfEnum    `json:"brwf"`
	Patternschema []byte      `json:"patternschema"`
	Actionschema  []byte      `json:"actionschema"`
	Editedby      pgtype.Text `json:"editedby"`
	RealmName     string      `json:"realm_name"`
	Slice         int32       `json:"slice"`
	App           string      `json:"app"`
}

func (q *Queries) SchemaUpdate(ctx context.Context, arg SchemaUpdateParams) error {
	_, err := q.db.Exec(ctx, schemaUpdate,
		arg.Class,
		arg.Brwf,
		arg.Patternschema,
		arg.Actionschema,
		arg.Editedby,
		arg.RealmName,
		arg.Slice,
		arg.App,
	)
	return err
}

const wfPatternSchemaGet = `-- name: WfPatternSchemaGet :one
SELECT patternschema
FROM public.schema
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
    AND brwf = 'W'
`

type WfPatternSchemaGetParams struct {
	Realm string `json:"realm"`
	Slice int32  `json:"slice"`
	Class string `json:"class"`
	App   string `json:"app"`
}

func (q *Queries) WfPatternSchemaGet(ctx context.Context, arg WfPatternSchemaGetParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, wfPatternSchemaGet,
		arg.Realm,
		arg.Slice,
		arg.Class,
		arg.App,
	)
	var patternschema []byte
	err := row.Scan(&patternschema)
	return patternschema, err
}

const wfSchemaGet = `-- name: WfSchemaGet :one
SELECT id, realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby, editedat, editedby
FROM public.schema
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
`

type WfSchemaGetParams struct {
	Realm string `json:"realm"`
	Slice int32  `json:"slice"`
	Class string `json:"class"`
	App   string `json:"app"`
}

func (q *Queries) WfSchemaGet(ctx context.Context, arg WfSchemaGetParams) (Schema, error) {
	row := q.db.QueryRow(ctx, wfSchemaGet,
		arg.Realm,
		arg.Slice,
		arg.Class,
		arg.App,
	)
	var i Schema
	err := row.Scan(
		&i.ID,
		&i.Realm,
		&i.Slice,
		&i.App,
		&i.Brwf,
		&i.Class,
		&i.Patternschema,
		&i.Actionschema,
		&i.Createdat,
		&i.Createdby,
		&i.Editedat,
		&i.Editedby,
	)
	return i, err
}

const wfSchemaList = `-- name: WfSchemaList :many
SELECT schema.slice, schema.app, app.longname, schema.class, schema.createdby, schema.createdat, schema.editedby, schema.editedat
FROM schema, app, realmslice
where
    schema.app = app.shortname
    and schema.slice = realmslice.id
    AND schema.realm =  $1
    AND (($2::INTEGER is null) OR (schema.slice = $2::INTEGER))
    AND (($3::text is null) OR (schema.app = $3::text))
    AND ($4::text is null OR schema.class = $4::text)
`

type WfSchemaListParams struct {
	Relam string      `json:"relam"`
	Slice pgtype.Int4 `json:"slice"`
	App   pgtype.Text `json:"app"`
	Class pgtype.Text `json:"class"`
}

type WfSchemaListRow struct {
	Slice     int32            `json:"slice"`
	App       string           `json:"app"`
	Longname  string           `json:"longname"`
	Class     string           `json:"class"`
	Createdby string           `json:"createdby"`
	Createdat pgtype.Timestamp `json:"createdat"`
	Editedby  pgtype.Text      `json:"editedby"`
	Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) WfSchemaList(ctx context.Context, arg WfSchemaListParams) ([]WfSchemaListRow, error) {
	rows, err := q.db.Query(ctx, wfSchemaList,
		arg.Relam,
		arg.Slice,
		arg.App,
		arg.Class,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WfSchemaListRow
	for rows.Next() {
		var i WfSchemaListRow
		if err := rows.Scan(
			&i.Slice,
			&i.App,
			&i.Longname,
			&i.Class,
			&i.Createdby,
			&i.Createdat,
			&i.Editedby,
			&i.Editedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wfschemadelete = `-- name: Wfschemadelete :exec
DELETE from schema
where
    id in (
        select id
        from (
                SELECT schema.id
                FROM schema, realm, realmslice
                WHERE
                    schema.realm = realm.id
                    and schema.slice = realmslice.id
                    and schema.slice = $1
                    and realmslice.realm = realm.shortname
                    and schema.realm = $4
                    and schema.class = $3
                    AND schema.app = $2
            ) as id
        where
            id not in(
                SELECT schemaid
                FROM ruleset
                where
                    realm = $4
                    and slice = $1
                    and app = $2
                    and class = $3
            )
    )
`

type WfschemadeleteParams struct {
	Slice int32  `json:"slice"`
	App   string `json:"app"`
	Class string `json:"class"`
	Realm string `json:"realm"`
}

func (q *Queries) Wfschemadelete(ctx context.Context, arg WfschemadeleteParams) error {
	_, err := q.db.Exec(ctx, wfschemadelete,
		arg.Slice,
		arg.App,
		arg.Class,
		arg.Realm,
	)
	return err
}

const wfschemaget = `-- name: Wfschemaget :one
SELECT s.slice, s.app, s.class, rm.longname, s.patternschema, s.actionschema, s.createdat, s.createdby, s.editedat, s.editedby
FROM schema as s, realm as rm, realmslice as rs
WHERE
    s.realm = rm.shortname
    and rs.realm = rm.shortname
    and s.slice = rs.id
    and s.slice = $1
    and rm.shortname = $4
    and s.class = $3
    AND s.app = $2
`

type WfschemagetParams struct {
	Slice int32  `json:"slice"`
	App   string `json:"app"`
	Class string `json:"class"`
	Realm string `json:"realm"`
}

type WfschemagetRow struct {
	Slice         int32            `json:"slice"`
	App           string           `json:"app"`
	Class         string           `json:"class"`
	Longname      string           `json:"longname"`
	Patternschema []byte           `json:"patternschema"`
	Actionschema  []byte           `json:"actionschema"`
	Createdat     pgtype.Timestamp `json:"createdat"`
	Createdby     string           `json:"createdby"`
	Editedat      pgtype.Timestamp `json:"editedat"`
	Editedby      pgtype.Text      `json:"editedby"`
}

func (q *Queries) Wfschemaget(ctx context.Context, arg WfschemagetParams) (WfschemagetRow, error) {
	row := q.db.QueryRow(ctx, wfschemaget,
		arg.Slice,
		arg.App,
		arg.Class,
		arg.Realm,
	)
	var i WfschemagetRow
	err := row.Scan(
		&i.Slice,
		&i.App,
		&i.Class,
		&i.Longname,
		&i.Patternschema,
		&i.Actionschema,
		&i.Createdat,
		&i.Createdby,
		&i.Editedat,
		&i.Editedby,
	)
	return i, err
}
