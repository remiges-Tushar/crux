
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>db: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/remiges-tech/crux/db/error.go (28.6%)</option>
				
				<option value="file1">github.com/remiges-tech/crux/db/pg.go (75.0%)</option>
				
				<option value="file2">github.com/remiges-tech/crux/db/sqlc-gen/app.sql.go (0.0%)</option>
				
				<option value="file3">github.com/remiges-tech/crux/db/sqlc-gen/capgrant.sql.go (0.0%)</option>
				
				<option value="file4">github.com/remiges-tech/crux/db/sqlc-gen/config.sql.go (80.0%)</option>
				
				<option value="file5">github.com/remiges-tech/crux/db/sqlc-gen/db.go (50.0%)</option>
				
				<option value="file6">github.com/remiges-tech/crux/db/sqlc-gen/deactivated.sql.go (0.0%)</option>
				
				<option value="file7">github.com/remiges-tech/crux/db/sqlc-gen/models.go (0.0%)</option>
				
				<option value="file8">github.com/remiges-tech/crux/db/sqlc-gen/realmslice.sql.go (0.0%)</option>
				
				<option value="file9">github.com/remiges-tech/crux/db/sqlc-gen/ruleset.sql.go (0.0%)</option>
				
				<option value="file10">github.com/remiges-tech/crux/db/sqlc-gen/schema.sql.go (0.0%)</option>
				
				<option value="file11">github.com/remiges-tech/crux/db/sqlc-gen/sqlc_tx.go (0.0%)</option>
				
				<option value="file12">github.com/remiges-tech/crux/db/sqlc-gen/stepworkflow.sql.go (0.0%)</option>
				
				<option value="file13">github.com/remiges-tech/crux/db/sqlc-gen/wfinstance.sql.go (0.0%)</option>
				
				<option value="file14">github.com/remiges-tech/crux/matching-engine/cache.go (0.0%)</option>
				
				<option value="file15">github.com/remiges-tech/crux/matching-engine/cache_data_structures.go (0.0%)</option>
				
				<option value="file16">github.com/remiges-tech/crux/matching-engine/cache_stats_collection.go (0.0%)</option>
				
				<option value="file17">github.com/remiges-tech/crux/matching-engine/cache_utils.go (0.0%)</option>
				
				<option value="file18">github.com/remiges-tech/crux/matching-engine/collect_actions.go (0.0%)</option>
				
				<option value="file19">github.com/remiges-tech/crux/matching-engine/do_match.go (0.0%)</option>
				
				<option value="file20">github.com/remiges-tech/crux/matching-engine/match_pattern.go (0.0%)</option>
				
				<option value="file21">github.com/remiges-tech/crux/matching-engine/verify_data.go (0.0%)</option>
				
				<option value="file22">github.com/remiges-tech/crux/server/config/configGet.go (52.4%)</option>
				
				<option value="file23">github.com/remiges-tech/crux/server/config/configSet.go (81.2%)</option>
				
				<option value="file24">github.com/remiges-tech/crux/server/wsc_utils.go (3.1%)</option>
				
				<option value="file25">github.com/remiges-tech/crux/testutils/test_utils.go (75.0%)</option>
				
				<option value="file26">github.com/remiges-tech/crux/types/types.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package db

import (
        "errors"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/server"
)

// The function HandleDatabaseError first checks if the error is a PostgreSQL-specific error
//
//        by attempting to cast it to a *pgconn.PgError. If successful, it examines the PostgreSQL
//        error code to determine the nature of the error.If none of the above conditions are met,
//        it constructs a generic error message indicating an internal server error related to
//
// the database.
func HandleDatabaseError(err error) wscutils.ErrorMessage <span class="cov8" title="1">{
        var pgErr *pgconn.PgError

        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                switch pgErr.Code </span>{
                case "23505":<span class="cov0" title="0"> //unique_violation
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ErrCode_AlreadyExist, &amp;pgErr.ConstraintName)</span>
                case "23503":<span class="cov8" title="1"> //foreign_key_violation
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ErrCode_NotFound, &amp;pgErr.ConstraintName)</span>
                case "23502":<span class="cov0" title="0"> //not_null_violation
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ErrCode_Invalid, &amp;pgErr.ColumnName)</span>
                case "0A000":<span class="cov0" title="0"> //ERROR: cached plan must not change result type (SQLSTATE 0A000)

                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_Internal_Retry, nil)</span>
                case "XX000":<span class="cov0" title="0"> //ERROR: cache lookup failed for type 67119 (SQLSTATE XX000)
                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_Internal_Retry, nil)</span>
                default:<span class="cov0" title="0">
                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil)</span>
                }
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "no rows in result set" </span><span class="cov0" title="0">{
                        // field := "slice/app/class"
                        return wscutils.BuildErrorMessage(server.MsgId_Invalid_Request, server.ERRCode_No_record_Found, nil)
                }</span> else<span class="cov0" title="0"> {
                        return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil)
                }</span>
        } else<span class="cov0" title="0"> {
                return wscutils.BuildErrorMessage(server.MsgId_InternalErr, server.ErrCode_DatabaseError, nil)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgxpool"
)

func NewProvider(connString string) (*pgxpool.Pool, error) <span class="cov8" title="1">{
        ctx := context.Background()
        connPool, err := pgxpool.New(ctx, connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = connPool.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return connPool, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: app.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const appDelete = `-- name: AppDelete :exec
DELETE FROM app
WHERE shortnamelc = $1 AND realm = $2
`

type AppDeleteParams struct {
        Shortnamelc string `json:"shortnamelc"`
        Realm       string `json:"realm"`
}

func (q *Queries) AppDelete(ctx context.Context, arg AppDeleteParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, appDelete, arg.Shortnamelc, arg.Realm)
        return err
}</span>

const appExist = `-- name: AppExist :one
SELECT
    CASE
        WHEN EXISTS (SELECT 1 FROM schema WHERE schema.app = $1) OR
             EXISTS (SELECT 1 FROM ruleset WHERE ruleset.app = $1)
        THEN 1
        ELSE 0
    END AS value_exists
`

func (q *Queries) AppExist(ctx context.Context, app string) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, appExist, app)
        var value_exists int32
        err := row.Scan(&amp;value_exists)
        return value_exists, err
}</span>

const appNew = `-- name: AppNew :many
INSERT INTO
    app (
        realm, shortname, shortnamelc, longname, setby
    )
VALUES (
        $1, $2, $3, $4, $5
    )
RETURNING
    id, realm, shortname, shortnamelc, longname, setby, setat
`

type AppNewParams struct {
        Realm       string `json:"realm"`
        Shortname   string `json:"shortname"`
        Shortnamelc string `json:"shortnamelc"`
        Longname    string `json:"longname"`
        Setby       string `json:"setby"`
}

func (q *Queries) AppNew(ctx context.Context, arg AppNewParams) ([]App, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, appNew,
                arg.Realm,
                arg.Shortname,
                arg.Shortnamelc,
                arg.Longname,
                arg.Setby,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []App
        for rows.Next() </span><span class="cov0" title="0">{
                var i App
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Shortname,
                        &amp;i.Shortnamelc,
                        &amp;i.Longname,
                        &amp;i.Setby,
                        &amp;i.Setat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const appUpdate = `-- name: AppUpdate :exec
UPDATE app
set
    longname = $1,
    setat = NOW(),
    setby = $2
WHERE
    shortnamelc = $3
    AND realm = $4
`

type AppUpdateParams struct {
        Longname    string `json:"longname"`
        Setby       string `json:"setby"`
        Shortnamelc string `json:"shortnamelc"`
        Realm       string `json:"realm"`
}

func (q *Queries) AppUpdate(ctx context.Context, arg AppUpdateParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, appUpdate,
                arg.Longname,
                arg.Setby,
                arg.Shortnamelc,
                arg.Realm,
        )
        return err
}</span>

const getAppList = `-- name: GetAppList :many
SELECT
    a.shortnamelc AS name,
    a.longname AS descr,
    a.setat AS createdat,
    a.setby AS createdby,
    ( SELECT COUNT(DISTINCT "user")
        FROM capgrant
        WHERE app = a.shortnamelc
    ) AS nusers,
    ( SELECT COUNT(*)
        FROM ruleset
        WHERE app = a.shortnamelc AND brwf = 'B'
    ) AS nrulesetsbre,
    ( SELECT COUNT(*)
        FROM ruleset
        WHERE app = a.shortnamelc AND brwf = 'W'
    ) AS nrulesetswfe
FROM
    app a
WHERE
a.realm= $1
`

type GetAppListRow struct {
        Name         string           `json:"name"`
        Descr        string           `json:"descr"`
        Createdat    pgtype.Timestamp `json:"createdat"`
        Createdby    string           `json:"createdby"`
        Nusers       int64            `json:"nusers"`
        Nrulesetsbre int64            `json:"nrulesetsbre"`
        Nrulesetswfe int64            `json:"nrulesetswfe"`
}

func (q *Queries) GetAppList(ctx context.Context, realm string) ([]GetAppListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAppList, realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetAppListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetAppListRow
                if err := rows.Scan(
                        &amp;i.Name,
                        &amp;i.Descr,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Nusers,
                        &amp;i.Nrulesetsbre,
                        &amp;i.Nrulesetswfe,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getAppName = `-- name: GetAppName :many
select id, realm, shortname, shortnamelc, longname, setby, setat FROM app WHERE shortnamelc = $1 AND realm = $2
`

type GetAppNameParams struct {
        Shortnamelc string `json:"shortnamelc"`
        Realm       string `json:"realm"`
}

func (q *Queries) GetAppName(ctx context.Context, arg GetAppNameParams) ([]App, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAppName, arg.Shortnamelc, arg.Realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []App
        for rows.Next() </span><span class="cov0" title="0">{
                var i App
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Shortname,
                        &amp;i.Shortnamelc,
                        &amp;i.Longname,
                        &amp;i.Setby,
                        &amp;i.Setat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: capgrant.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const deleteCapGranForApp = `-- name: DeleteCapGranForApp :exec

DELETE FROM capgrant WHERE app = $1 AND realm = $2
`

type DeleteCapGranForAppParams struct {
        App   pgtype.Text `json:"app"`
        Realm string      `json:"realm"`
}

func (q *Queries) DeleteCapGranForApp(ctx context.Context, arg DeleteCapGranForAppParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteCapGranForApp, arg.App, arg.Realm)
        return err
}</span>

const getCapGrantForApp = `-- name: GetCapGrantForApp :many

SELECT id, realm, "user", app, cap, "from", "to", setat, setby FROM capgrant WHERE app = $1 AND realm = $2
`

type GetCapGrantForAppParams struct {
        App   pgtype.Text `json:"app"`
        Realm string      `json:"realm"`
}

func (q *Queries) GetCapGrantForApp(ctx context.Context, arg GetCapGrantForAppParams) ([]Capgrant, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getCapGrantForApp, arg.App, arg.Realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Capgrant
        for rows.Next() </span><span class="cov0" title="0">{
                var i Capgrant
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.User,
                        &amp;i.App,
                        &amp;i.Cap,
                        &amp;i.From,
                        &amp;i.To,
                        &amp;i.Setat,
                        &amp;i.Setby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const userActivate = `-- name: UserActivate :one
UPDATE capgrant
SET
    "from" = CASE
        WHEN (
            $1::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $1::TIMESTAMP
        )
    END,
    "to" = NULL
WHERE
    "user" = $2
    and realm = $3
RETURNING id, realm, "user", app, cap, "from", "to", setat, setby
`

type UserActivateParams struct {
        Activateat pgtype.Timestamp `json:"activateat"`
        Userid     string           `json:"userid"`
        Realm      string           `json:"realm"`
}

func (q *Queries) UserActivate(ctx context.Context, arg UserActivateParams) (Capgrant, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, userActivate, arg.Activateat, arg.Userid, arg.Realm)
        var i Capgrant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.User,
                &amp;i.App,
                &amp;i.Cap,
                &amp;i.From,
                &amp;i.To,
                &amp;i.Setat,
                &amp;i.Setby,
        )
        return i, err
}</span>

const userDeactivate = `-- name: UserDeactivate :one
UPDATE capgrant
SET
    "to" = CASE
        WHEN (
            $1::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $1::TIMESTAMP
        )
    END,
    "from" = NULL
WHERE
    "user" = $2
    and realm = $3
RETURNING id, realm, "user", app, cap, "from", "to", setat, setby
`

type UserDeactivateParams struct {
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        Userid       string           `json:"userid"`
        Realm        string           `json:"realm"`
}

func (q *Queries) UserDeactivate(ctx context.Context, arg UserDeactivateParams) (Capgrant, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, userDeactivate, arg.Deactivateat, arg.Userid, arg.Realm)
        var i Capgrant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.User,
                &amp;i.App,
                &amp;i.Cap,
                &amp;i.From,
                &amp;i.To,
                &amp;i.Setat,
                &amp;i.Setby,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: config.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const configGet = `-- name: ConfigGet :many
SELECT 
name AS attr,
val,ver,
setby AS by
FROM config 
where realm = (SELECT realm.shortnamelc FROM realm WHERE realm.shortnamelc = $1)
`

type ConfigGetRow struct {
        Attr string      `json:"attr"`
        Val  pgtype.Text `json:"val"`
        Ver  pgtype.Int4 `json:"ver"`
        By   string      `json:"by"`
}

func (q *Queries) ConfigGet(ctx context.Context, shortnamelc string) ([]ConfigGetRow, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, configGet, shortnamelc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        var items []ConfigGetRow
        for rows.Next() </span><span class="cov8" title="1">{
                var i ConfigGetRow
                if err := rows.Scan(
                        &amp;i.Attr,
                        &amp;i.Val,
                        &amp;i.Ver,
                        &amp;i.By,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const configSet = `-- name: ConfigSet :exec
INSERT INTO
    config(
        realm, slice, name, descr, val, setby
    )
VALUES (
        $1, $2, $3, $4, $5, $6
    )
`

type ConfigSetParams struct {
        Realm string      `json:"realm"`
        Slice int32       `json:"slice"`
        Name  string      `json:"name"`
        Descr string      `json:"descr"`
        Val   pgtype.Text `json:"val"`
        Setby string      `json:"setby"`
}

func (q *Queries) ConfigSet(ctx context.Context, arg ConfigSetParams) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, configSet,
                arg.Realm,
                arg.Slice,
                arg.Name,
                arg.Descr,
                arg.Val,
                arg.Setby,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: deactivated.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const activateRecord = `-- name: ActivateRecord :exec
DELETE FROM deactivated WHERE realm = $1 and "user"= $2
`

type ActivateRecordParams struct {
        Realm  string      `json:"realm"`
        Userid pgtype.Text `json:"userid"`
}

func (q *Queries) ActivateRecord(ctx context.Context, arg ActivateRecordParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, activateRecord, arg.Realm, arg.Userid)
        return err
}</span>

const deactivateRecord = `-- name: DeactivateRecord :exec
INSERT INTO deactivated (realm , "user", deactby, deactat)
VALUES ($1,$2,$3,$4)
`

type DeactivateRecordParams struct {
        Realm   string           `json:"realm"`
        Userid  pgtype.Text      `json:"userid"`
        Deactby string           `json:"deactby"`
        Deactat pgtype.Timestamp `json:"deactat"`
}

func (q *Queries) DeactivateRecord(ctx context.Context, arg DeactivateRecordParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deactivateRecord,
                arg.Realm,
                arg.Userid,
                arg.Deactby,
                arg.Deactat,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package sqlc

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type BrwfEnum string

const (
        BrwfEnumB BrwfEnum = "B"
        BrwfEnumW BrwfEnum = "W"
)

func (e *BrwfEnum) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = BrwfEnum(s)</span>
        case string:<span class="cov0" title="0">
                *e = BrwfEnum(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for BrwfEnum: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullBrwfEnum struct {
        BrwfEnum BrwfEnum `json:"brwf_enum"`
        Valid    bool     `json:"valid"` // Valid is true if BrwfEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBrwfEnum) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.BrwfEnum, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.BrwfEnum.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullBrwfEnum) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.BrwfEnum), nil</span>
}

type App struct {
        ID          int32            `json:"id"`
        Realm       string           `json:"realm"`
        Shortname   string           `json:"shortname"`
        Shortnamelc string           `json:"shortnamelc"`
        Longname    string           `json:"longname"`
        Setby       string           `json:"setby"`
        Setat       pgtype.Timestamp `json:"setat"`
}

type Capgrant struct {
        ID    int32            `json:"id"`
        Realm string           `json:"realm"`
        User  string           `json:"user"`
        App   pgtype.Text      `json:"app"`
        Cap   string           `json:"cap"`
        From  pgtype.Timestamp `json:"from"`
        To    pgtype.Timestamp `json:"to"`
        Setat pgtype.Timestamp `json:"setat"`
        Setby string           `json:"setby"`
}

type Config struct {
        Realm string           `json:"realm"`
        Slice int32            `json:"slice"`
        Name  string           `json:"name"`
        Descr string           `json:"descr"`
        Val   pgtype.Text      `json:"val"`
        Ver   pgtype.Int4      `json:"ver"`
        Setby string           `json:"setby"`
        Setat pgtype.Timestamp `json:"setat"`
}

type Deactivated struct {
        ID      int32            `json:"id"`
        Realm   string           `json:"realm"`
        User    pgtype.Text      `json:"user"`
        Deactby string           `json:"deactby"`
        Deactat pgtype.Timestamp `json:"deactat"`
}

type Realm struct {
        ID          int32            `json:"id"`
        Shortname   string           `json:"shortname"`
        Shortnamelc string           `json:"shortnamelc"`
        Longname    string           `json:"longname"`
        Setby       string           `json:"setby"`
        Setat       pgtype.Timestamp `json:"setat"`
        Payload     []byte           `json:"payload"`
}

type Realmslice struct {
        ID           int32            `json:"id"`
        Realm        string           `json:"realm"`
        Descr        string           `json:"descr"`
        Active       bool             `json:"active"`
        Activateat   pgtype.Timestamp `json:"activateat"`
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        Createdat    pgtype.Timestamp `json:"createdat"`
        Createdby    string           `json:"createdby"`
        Editedat     pgtype.Timestamp `json:"editedat"`
        Editedby     pgtype.Text      `json:"editedby"`
}

type Ruleset struct {
        ID         int32            `json:"id"`
        Realm      string           `json:"realm"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Brwf       BrwfEnum         `json:"brwf"`
        Class      string           `json:"class"`
        Setname    string           `json:"setname"`
        Schemaid   int32            `json:"schemaid"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Ruleset    []byte           `json:"ruleset"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

type Schema struct {
        ID            int32            `json:"id"`
        Realm         string           `json:"realm"`
        Slice         int32            `json:"slice"`
        App           string           `json:"app"`
        Brwf          BrwfEnum         `json:"brwf"`
        Class         string           `json:"class"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Createdat     pgtype.Timestamp `json:"createdat"`
        Createdby     string           `json:"createdby"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

type Stepworkflow struct {
        Slice    int32       `json:"slice"`
        App      pgtype.Text `json:"app"`
        Step     string      `json:"step"`
        Workflow string      `json:"workflow"`
}

type Wfinstance struct {
        ID       int32            `json:"id"`
        Entityid string           `json:"entityid"`
        Slice    int32            `json:"slice"`
        App      string           `json:"app"`
        Class    string           `json:"class"`
        Workflow string           `json:"workflow"`
        Step     string           `json:"step"`
        Loggedat pgtype.Timestamp `json:"loggedat"`
        Doneat   pgtype.Timestamp `json:"doneat"`
        Nextstep string           `json:"nextstep"`
        Parent   pgtype.Int4      `json:"parent"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: realmslice.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgtype"
)

const cloneRecordInConfigBySliceID = `-- name: CloneRecordInConfigBySliceID :execresult
INSERT INTO
    config (
        realm, slice, name, descr, val, ver, setby
    )
SELECT realm, $2, name, descr, val, ver, $3
FROM config
WHERE
    config.slice = $1
`

type CloneRecordInConfigBySliceIDParams struct {
        Slice   int32  `json:"slice"`
        Slice_2 int32  `json:"slice_2"`
        Setby   string `json:"setby"`
}

func (q *Queries) CloneRecordInConfigBySliceID(ctx context.Context, arg CloneRecordInConfigBySliceIDParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, cloneRecordInConfigBySliceID, arg.Slice, arg.Slice_2, arg.Setby)
}</span>

const cloneRecordInRealmSliceBySliceID = `-- name: CloneRecordInRealmSliceBySliceID :one
INSERT INTO
    realmslice (
        realm, descr, active, activateat, deactivateat,createdby
    )
SELECT
    realm,
    COALESCE(
        descr, $4::text
    ),
    true,
    activateat,
    deactivateat,
    $3
FROM realmslice
WHERE
    realmslice.id = $1
    AND realmslice.realm = $2
RETURNING
    realmslice.id
`

type CloneRecordInRealmSliceBySliceIDParams struct {
        ID        int32       `json:"id"`
        Realm     string      `json:"realm"`
        Createdby string      `json:"createdby"`
        Descr     pgtype.Text `json:"descr"`
}

func (q *Queries) CloneRecordInRealmSliceBySliceID(ctx context.Context, arg CloneRecordInRealmSliceBySliceIDParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, cloneRecordInRealmSliceBySliceID,
                arg.ID,
                arg.Realm,
                arg.Createdby,
                arg.Descr,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const cloneRecordInRulesetBySliceID = `-- name: CloneRecordInRulesetBySliceID :execresult
INSERT INTO
    ruleset (
        realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdby
    )
SELECT
    realm,
    $2,
    app,
    brwf,
    class,
    setname,
    schemaid,
    is_active,
    is_internal,
    ruleset,
    $3
FROM ruleset
WHERE
    ruleset.slice = $1
    AND (
        $4::text [] is null
        OR app = any ($4::text [])
    )
`

type CloneRecordInRulesetBySliceIDParams struct {
        Slice     int32    `json:"slice"`
        Slice_2   int32    `json:"slice_2"`
        Createdby string   `json:"createdby"`
        App       []string `json:"app"`
}

func (q *Queries) CloneRecordInRulesetBySliceID(ctx context.Context, arg CloneRecordInRulesetBySliceIDParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, cloneRecordInRulesetBySliceID,
                arg.Slice,
                arg.Slice_2,
                arg.Createdby,
                arg.App,
        )
}</span>

const cloneRecordInSchemaBySliceID = `-- name: CloneRecordInSchemaBySliceID :execresult
INSERT INTO
    schema (
        realm, slice, app, brwf, class, patternschema, actionschema, createdby
    )
SELECT
    realm,
    $2,
    app,
    brwf,
    class,
    patternschema,
    actionschema,
    $3
FROM schema
WHERE
    schema.slice = $1
    AND (
        $4::text [] is null
        OR app = any ($4::text [])
    )
`

type CloneRecordInSchemaBySliceIDParams struct {
        Slice     int32    `json:"slice"`
        Slice_2   int32    `json:"slice_2"`
        Createdby string   `json:"createdby"`
        App       []string `json:"app"`
}

func (q *Queries) CloneRecordInSchemaBySliceID(ctx context.Context, arg CloneRecordInSchemaBySliceIDParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, cloneRecordInSchemaBySliceID,
                arg.Slice,
                arg.Slice_2,
                arg.Createdby,
                arg.App,
        )
}</span>

const getRealmSliceListByRealm = `-- name: GetRealmSliceListByRealm :many
SELECT
    id,descr,active,deactivateat,createdat,createdby,editedat,editedby
FROM
    realmslice
WHERE
    realm= $1
`

type GetRealmSliceListByRealmRow struct {
        ID           int32            `json:"id"`
        Descr        string           `json:"descr"`
        Active       bool             `json:"active"`
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        Createdat    pgtype.Timestamp `json:"createdat"`
        Createdby    string           `json:"createdby"`
        Editedat     pgtype.Timestamp `json:"editedat"`
        Editedby     pgtype.Text      `json:"editedby"`
}

func (q *Queries) GetRealmSliceListByRealm(ctx context.Context, realm string) ([]GetRealmSliceListByRealmRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getRealmSliceListByRealm, realm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetRealmSliceListByRealmRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetRealmSliceListByRealmRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Descr,
                        &amp;i.Active,
                        &amp;i.Deactivateat,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const insertNewRecordInRealmSlice = `-- name: InsertNewRecordInRealmSlice :one
INSERT INTO
    realmslice (
        realm, descr, active, createdby
    )
VALUES ($1, $2, true, $3) RETURNING realmslice.id
`

type InsertNewRecordInRealmSliceParams struct {
        Realm     string `json:"realm"`
        Descr     string `json:"descr"`
        Createdby string `json:"createdby"`
}

func (q *Queries) InsertNewRecordInRealmSlice(ctx context.Context, arg InsertNewRecordInRealmSliceParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, insertNewRecordInRealmSlice, arg.Realm, arg.Descr, arg.Createdby)
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const realmSliceActivate = `-- name: RealmSliceActivate :one
UPDATE realmslice
SET
    active = $1,
    activateat = CASE
        WHEN (
            $2::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $2::TIMESTAMP
        )
    END,
    deactivateat = NULL
WHERE
    id = $3
RETURNING
    id, realm, descr, active, activateat, deactivateat, createdat, createdby, editedat, editedby
`

type RealmSliceActivateParams struct {
        Isactive   bool             `json:"isactive"`
        Activateat pgtype.Timestamp `json:"activateat"`
        ID         int32            `json:"id"`
}

func (q *Queries) RealmSliceActivate(ctx context.Context, arg RealmSliceActivateParams) (Realmslice, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, realmSliceActivate, arg.Isactive, arg.Activateat, arg.ID)
        var i Realmslice
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Descr,
                &amp;i.Active,
                &amp;i.Activateat,
                &amp;i.Deactivateat,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const realmSliceAppsList = `-- name: RealmSliceAppsList :many
SELECT a.shortname, a.longname
FROM realmslice
    JOIN app a ON realmslice.realm = a.realm
WHERE
    realmslice.id = $1
`

type RealmSliceAppsListRow struct {
        Shortname string `json:"shortname"`
        Longname  string `json:"longname"`
}

func (q *Queries) RealmSliceAppsList(ctx context.Context, id int32) ([]RealmSliceAppsListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, realmSliceAppsList, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []RealmSliceAppsListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i RealmSliceAppsListRow
                if err := rows.Scan(&amp;i.Shortname, &amp;i.Longname); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const realmSliceDeactivate = `-- name: RealmSliceDeactivate :one
UPDATE realmslice
SET
    active = $1,
    deactivateat = CASE
        WHEN (
            $2::TIMESTAMP
        ) IS NULL THEN NOW()
        ELSE (
            $2::TIMESTAMP
        )
    END,
    activateat = NULL
WHERE
    id = $3
RETURNING
    id, realm, descr, active, activateat, deactivateat, createdat, createdby, editedat, editedby
`

type RealmSliceDeactivateParams struct {
        Isactive     bool             `json:"isactive"`
        Deactivateat pgtype.Timestamp `json:"deactivateat"`
        ID           int32            `json:"id"`
}

func (q *Queries) RealmSliceDeactivate(ctx context.Context, arg RealmSliceDeactivateParams) (Realmslice, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, realmSliceDeactivate, arg.Isactive, arg.Deactivateat, arg.ID)
        var i Realmslice
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Descr,
                &amp;i.Active,
                &amp;i.Activateat,
                &amp;i.Deactivateat,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const realmSlicePurge = `-- name: RealmSlicePurge :execresult
WITH
    del_stepworkflow AS (
        DELETE FROM stepworkflow
    ),
    del_wfinstance AS (
        DELETE FROM wfinstance
    ),
    del_ruleset AS (
        DELETE FROM ruleset
    ),
    del_schema AS (
        DELETE FROM schema
    ),
    del_config AS (
        DELETE FROM config
    )
DELETE FROM realmslice
WHERE
    realmslice.realm = $1
`

func (q *Queries) RealmSlicePurge(ctx context.Context, realm string) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, realmSlicePurge, realm)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: ruleset.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgtype"
)

const allRuleset = `-- name: AllRuleset :many
SELECT
    id, realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdat, createdby, editedat, editedby
FROM
    public.ruleset
`

func (q *Queries) AllRuleset(ctx context.Context) ([]Ruleset, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, allRuleset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Ruleset
        for rows.Next() </span><span class="cov0" title="0">{
                var i Ruleset
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Brwf,
                        &amp;i.Class,
                        &amp;i.Setname,
                        &amp;i.Schemaid,
                        &amp;i.IsActive,
                        &amp;i.IsInternal,
                        &amp;i.Ruleset,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getApp = `-- name: GetApp :one
SELECT app
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
`

type GetAppParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
        Realm string `json:"realm"`
}

func (q *Queries) GetApp(ctx context.Context, arg GetAppParams) (string, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getApp,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
        )
        var app string
        err := row.Scan(&amp;app)
        return app, err
}</span>

const getClass = `-- name: GetClass :one
SELECT class
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
`

type GetClassParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
        Realm string `json:"realm"`
}

func (q *Queries) GetClass(ctx context.Context, arg GetClassParams) (string, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getClass,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
        )
        var class string
        err := row.Scan(&amp;class)
        return class, err
}</span>

const getWFActiveStatus = `-- name: GetWFActiveStatus :one
SELECT is_active
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
    AND setname = $5
`

type GetWFActiveStatusParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Realm   string `json:"realm"`
        Setname string `json:"setname"`
}

func (q *Queries) GetWFActiveStatus(ctx context.Context, arg GetWFActiveStatusParams) (pgtype.Bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFActiveStatus,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
                arg.Setname,
        )
        var is_active pgtype.Bool
        err := row.Scan(&amp;is_active)
        return is_active, err
}</span>

const getWFInternalStatus = `-- name: GetWFInternalStatus :one
SELECT is_internal
FROM ruleset
WHERE
    slice = $1
    AND app = $2
    AND class = $3
    AND realm = $4
    AND brwf = 'W'
    AND setname = $5
`

type GetWFInternalStatusParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Realm   string `json:"realm"`
        Setname string `json:"setname"`
}

func (q *Queries) GetWFInternalStatus(ctx context.Context, arg GetWFInternalStatusParams) (bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFInternalStatus,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
                arg.Setname,
        )
        var is_internal bool
        err := row.Scan(&amp;is_internal)
        return is_internal, err
}</span>

const rulesetRowLock = `-- name: RulesetRowLock :one
SELECT id, realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdat, createdby, editedat, editedby 
FROM ruleset 
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
FOR UPDATE
`

type RulesetRowLockParams struct {
        Realm string `json:"realm"`
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

func (q *Queries) RulesetRowLock(ctx context.Context, arg RulesetRowLockParams) (Ruleset, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, rulesetRowLock,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
        )
        var i Ruleset
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Brwf,
                &amp;i.Class,
                &amp;i.Setname,
                &amp;i.Schemaid,
                &amp;i.IsActive,
                &amp;i.IsInternal,
                &amp;i.Ruleset,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const workFlowNew = `-- name: WorkFlowNew :exec
INSERT INTO
    ruleset (
        realm, slice, app, brwf, class, setname, schemaid, is_active, is_internal, ruleset, createdat, createdby
    )
VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, CURRENT_TIMESTAMP, $11
    )
`

type WorkFlowNewParams struct {
        Realm      string      `json:"realm"`
        Slice      int32       `json:"slice"`
        App        string      `json:"app"`
        Brwf       BrwfEnum    `json:"brwf"`
        Class      string      `json:"class"`
        Setname    string      `json:"setname"`
        Schemaid   int32       `json:"schemaid"`
        IsActive   pgtype.Bool `json:"is_active"`
        IsInternal bool        `json:"is_internal"`
        Ruleset    []byte      `json:"ruleset"`
        Createdby  string      `json:"createdby"`
}

func (q *Queries) WorkFlowNew(ctx context.Context, arg WorkFlowNewParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, workFlowNew,
                arg.Realm,
                arg.Slice,
                arg.App,
                arg.Brwf,
                arg.Class,
                arg.Setname,
                arg.Schemaid,
                arg.IsActive,
                arg.IsInternal,
                arg.Ruleset,
                arg.Createdby,
        )
        return err
}</span>

const workFlowUpdate = `-- name: WorkFlowUpdate :execresult
UPDATE ruleset
SET
    brwf = $5,
    setname = $6,
    ruleset = $7,
    editedat = CURRENT_TIMESTAMP,
    editedby = $8
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
`

type WorkFlowUpdateParams struct {
        Realm    string      `json:"realm"`
        Slice    int32       `json:"slice"`
        Class    string      `json:"class"`
        App      string      `json:"app"`
        Brwf     BrwfEnum    `json:"brwf"`
        Setname  string      `json:"setname"`
        Ruleset  []byte      `json:"ruleset"`
        Editedby pgtype.Text `json:"editedby"`
}

func (q *Queries) WorkFlowUpdate(ctx context.Context, arg WorkFlowUpdateParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, workFlowUpdate,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
                arg.Brwf,
                arg.Setname,
                arg.Ruleset,
                arg.Editedby,
        )
}</span>

const workflowDelete = `-- name: WorkflowDelete :execresult
DELETE from ruleset
where
    brwf = 'W'
    AND is_active = false
    and slice = $1
    and app = $2
    and class = $3
    and setname = $4
    AND realm = $5
`

type WorkflowDeleteParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Setname string `json:"setname"`
        Realm   string `json:"realm"`
}

func (q *Queries) WorkflowDelete(ctx context.Context, arg WorkflowDeleteParams) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        return q.db.Exec(ctx, workflowDelete,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
                arg.Realm,
        )
}</span>

const workflowList = `-- name: WorkflowList :many
select
    id,
    slice,
    app,
    class,
    setname as name,
    is_active,
    is_internal,
    createdat,
    createdby,
    editedat,
    editedby
from ruleset
where
    brwf = 'W'
    AND realm = $1
    AND ($2::INTEGER is null OR slice = $2::INTEGER)
    AND ( $3::text[] is null OR app = any( $3::text[]))
    AND ($4::text is null OR class = $4::text)
    AND ($5::text is null OR setname = $5::text)
    AND ($6::BOOLEAN is null OR is_active = $6::BOOLEAN)
    AND ($7::BOOLEAN is null OR is_internal = $7::BOOLEAN)
`

type WorkflowListParams struct {
        Realm      string      `json:"realm"`
        Slice      pgtype.Int4 `json:"slice"`
        App        []string    `json:"app"`
        Class      pgtype.Text `json:"class"`
        Setname    pgtype.Text `json:"setname"`
        IsActive   pgtype.Bool `json:"is_active"`
        IsInternal pgtype.Bool `json:"is_internal"`
}

type WorkflowListRow struct {
        ID         int32            `json:"id"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Class      string           `json:"class"`
        Name       string           `json:"name"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

func (q *Queries) WorkflowList(ctx context.Context, arg WorkflowListParams) ([]WorkflowListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, workflowList,
                arg.Realm,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
                arg.IsActive,
                arg.IsInternal,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []WorkflowListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i WorkflowListRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Name,
                        &amp;i.IsActive,
                        &amp;i.IsInternal,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const workflowget = `-- name: Workflowget :one
select
    id,
    slice,
    app,
    class,
    setname as name,
    is_active,
    is_internal,
    ruleset as flowrules,
    createdat,
    createdby,
    editedat,
    editedby
from ruleset
where
    slice = $1
    and app = $2
    and class = $3
    and setname = $4
    and realm = $5
    AND brwf = 'W'
`

type WorkflowgetParams struct {
        Slice   int32  `json:"slice"`
        App     string `json:"app"`
        Class   string `json:"class"`
        Setname string `json:"setname"`
        Realm   string `json:"realm"`
}

type WorkflowgetRow struct {
        ID         int32            `json:"id"`
        Slice      int32            `json:"slice"`
        App        string           `json:"app"`
        Class      string           `json:"class"`
        Name       string           `json:"name"`
        IsActive   pgtype.Bool      `json:"is_active"`
        IsInternal bool             `json:"is_internal"`
        Flowrules  []byte           `json:"flowrules"`
        Createdat  pgtype.Timestamp `json:"createdat"`
        Createdby  string           `json:"createdby"`
        Editedat   pgtype.Timestamp `json:"editedat"`
        Editedby   pgtype.Text      `json:"editedby"`
}

func (q *Queries) Workflowget(ctx context.Context, arg WorkflowgetParams) (WorkflowgetRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, workflowget,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Setname,
                arg.Realm,
        )
        var i WorkflowgetRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Name,
                &amp;i.IsActive,
                &amp;i.IsInternal,
                &amp;i.Flowrules,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: schema.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const allSchemas = `-- name: AllSchemas :many
SELECT id, realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby, editedat, editedby FROM public.schema
`

func (q *Queries) AllSchemas(ctx context.Context) ([]Schema, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, allSchemas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Schema
        for rows.Next() </span><span class="cov0" title="0">{
                var i Schema
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Realm,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Brwf,
                        &amp;i.Class,
                        &amp;i.Patternschema,
                        &amp;i.Actionschema,
                        &amp;i.Createdat,
                        &amp;i.Createdby,
                        &amp;i.Editedat,
                        &amp;i.Editedby,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getSchemaWithLock = `-- name: GetSchemaWithLock :one
SELECT
    id,
    brwf,
    patternschema,
    actionschema,
    editedat,
    editedby
FROM schema
WHERE
    realm = $4::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id=$1 AND realmslice.realm = $4)
    AND class = $2
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc=$3 AND app.realm = $4) FOR
UPDATE
`

type GetSchemaWithLockParams struct {
        ID          int32  `json:"id"`
        Class       string `json:"class"`
        Shortnamelc string `json:"shortnamelc"`
        RealmName   string `json:"realm_name"`
}

type GetSchemaWithLockRow struct {
        ID            int32            `json:"id"`
        Brwf          BrwfEnum         `json:"brwf"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

func (q *Queries) GetSchemaWithLock(ctx context.Context, arg GetSchemaWithLockParams) (GetSchemaWithLockRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getSchemaWithLock,
                arg.ID,
                arg.Class,
                arg.Shortnamelc,
                arg.RealmName,
        )
        var i GetSchemaWithLockRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Brwf,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const schemaDelete = `-- name: SchemaDelete :one
DELETE FROM schema WHERE id = $1 RETURNING id
`

func (q *Queries) SchemaDelete(ctx context.Context, id int32) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, schemaDelete, id)
        err := row.Scan(&amp;id)
        return id, err
}</span>

const schemaGet = `-- name: SchemaGet :many
SELECT schema.slice, schema.app, app.longname, schema.class, schema.createdby, schema.createdat, schema.editedby, schema.editedat
FROM schema
    JOIN app ON schema.app = app.shortname
    JOIN realmslice on schema.slice = realmslice.id
WHERE
    schema.realm = $1
    AND schema.slice = $2
    AND schema.class = $3
    AND schema.app = $4
`

type SchemaGetParams struct {
        Realm string `json:"realm"`
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

type SchemaGetRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) SchemaGet(ctx context.Context, arg SchemaGetParams) ([]SchemaGetRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, schemaGet,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []SchemaGetRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i SchemaGetRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const schemaNew = `-- name: SchemaNew :one
INSERT INTO
    schema(
        realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby
    )
VALUES (
        $8::varchar, 
        (SELECT realmslice.id FROM realmslice WHERE realmslice.id=$1 AND realmslice.realm = $8 ), 
        (SELECT app.shortnamelc FROM app WHERE app.shortnamelc=$2 AND app.realm = $8), 
        $3, $4, $5, $6, CURRENT_TIMESTAMP, $7
    ) RETURNING id
`

type SchemaNewParams struct {
        ID            int32    `json:"id"`
        Shortnamelc   string   `json:"shortnamelc"`
        Brwf          BrwfEnum `json:"brwf"`
        Class         string   `json:"class"`
        Patternschema []byte   `json:"patternschema"`
        Actionschema  []byte   `json:"actionschema"`
        Createdby     string   `json:"createdby"`
        RealmName     string   `json:"realm_name"`
}

func (q *Queries) SchemaNew(ctx context.Context, arg SchemaNewParams) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, schemaNew,
                arg.ID,
                arg.Shortnamelc,
                arg.Brwf,
                arg.Class,
                arg.Patternschema,
                arg.Actionschema,
                arg.Createdby,
                arg.RealmName,
        )
        var id int32
        err := row.Scan(&amp;id)
        return id, err
}</span>

const schemaUpdate = `-- name: SchemaUpdate :exec
UPDATE schema
SET
    brwf = $4,
    patternschema = COALESCE($5,patternschema),
    actionschema = COALESCE($6,actionschema),
    editedat = CURRENT_TIMESTAMP,
    editedby = $7
WHERE
    realm = $8::varchar
    AND slice = (SELECT realmslice.id FROM realmslice WHERE realmslice.id=$1 AND realmslice.realm = $8)
    AND class = $2
    AND app = (SELECT app.shortnamelc FROM app WHERE app.shortnamelc=$3 AND app.realm = $8)
`

type SchemaUpdateParams struct {
        ID            int32       `json:"id"`
        Class         string      `json:"class"`
        Shortnamelc   string      `json:"shortnamelc"`
        Brwf          BrwfEnum    `json:"brwf"`
        Patternschema []byte      `json:"patternschema"`
        Actionschema  []byte      `json:"actionschema"`
        Editedby      pgtype.Text `json:"editedby"`
        RealmName     string      `json:"realm_name"`
}

func (q *Queries) SchemaUpdate(ctx context.Context, arg SchemaUpdateParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, schemaUpdate,
                arg.ID,
                arg.Class,
                arg.Shortnamelc,
                arg.Brwf,
                arg.Patternschema,
                arg.Actionschema,
                arg.Editedby,
                arg.RealmName,
        )
        return err
}</span>

const wfPatternSchemaGet = `-- name: WfPatternSchemaGet :one
SELECT patternschema
FROM public.schema
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
    AND realm = $5
    AND brwf = 'W'
`

type WfPatternSchemaGetParams struct {
        Realm   string `json:"realm"`
        Slice   int32  `json:"slice"`
        Class   string `json:"class"`
        App     string `json:"app"`
        Realm_2 string `json:"realm_2"`
}

func (q *Queries) WfPatternSchemaGet(ctx context.Context, arg WfPatternSchemaGetParams) ([]byte, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, wfPatternSchemaGet,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
                arg.Realm_2,
        )
        var patternschema []byte
        err := row.Scan(&amp;patternschema)
        return patternschema, err
}</span>

const wfSchemaGet = `-- name: WfSchemaGet :one
SELECT id, realm, slice, app, brwf, class, patternschema, actionschema, createdat, createdby, editedat, editedby
FROM public.schema
WHERE
    realm = $1
    AND slice = $2
    AND class = $3
    AND app = $4
`

type WfSchemaGetParams struct {
        Realm string `json:"realm"`
        Slice int32  `json:"slice"`
        Class string `json:"class"`
        App   string `json:"app"`
}

func (q *Queries) WfSchemaGet(ctx context.Context, arg WfSchemaGetParams) (Schema, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, wfSchemaGet,
                arg.Realm,
                arg.Slice,
                arg.Class,
                arg.App,
        )
        var i Schema
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Realm,
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Brwf,
                &amp;i.Class,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>

const wfSchemaList = `-- name: WfSchemaList :many
SELECT schema.slice, schema.app, app.longname, schema.class, schema.createdby, schema.createdat, schema.editedby, schema.editedat
FROM schema, app, realmslice
where
schema.app = app.shortname
and schema.slice = realmslice.id
    AND schema.realm =  $1
    AND (($2::INTEGER is null) OR (schema.slice = $2::INTEGER))
    AND (($3::text is null) OR (schema.app = $3::text))
    AND ($4::text is null OR schema.class = $4::text)
`

type WfSchemaListParams struct {
        Relam string      `json:"relam"`
        Slice pgtype.Int4 `json:"slice"`
        App   pgtype.Text `json:"app"`
        Class pgtype.Text `json:"class"`
}

type WfSchemaListRow struct {
        Slice     int32            `json:"slice"`
        App       string           `json:"app"`
        Longname  string           `json:"longname"`
        Class     string           `json:"class"`
        Createdby string           `json:"createdby"`
        Createdat pgtype.Timestamp `json:"createdat"`
        Editedby  pgtype.Text      `json:"editedby"`
        Editedat  pgtype.Timestamp `json:"editedat"`
}

func (q *Queries) WfSchemaList(ctx context.Context, arg WfSchemaListParams) ([]WfSchemaListRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, wfSchemaList,
                arg.Relam,
                arg.Slice,
                arg.App,
                arg.Class,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []WfSchemaListRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i WfSchemaListRow
                if err := rows.Scan(
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Longname,
                        &amp;i.Class,
                        &amp;i.Createdby,
                        &amp;i.Createdat,
                        &amp;i.Editedby,
                        &amp;i.Editedat,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const wfschemadelete = `-- name: Wfschemadelete :exec
DELETE from schema
where
    id in (
        select id
        from (
                SELECT schema.id
                FROM schema, realm, realmslice
                WHERE
                    schema.realm = realm.id
                    and schema.slice = realmslice.id
                    and schema.slice = $1
                    and realmslice.realm = realm.shortname
                    and schema.realm = $4
                    and schema.class = $3
                    AND schema.app = $2
            ) as id
        where
            id not in(
                SELECT schemaid
                FROM ruleset
                where
                    realm = $4
                    and slice = $1
                    and app = $2
                    and class = $3
            )
    )
`

type WfschemadeleteParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
        Realm string `json:"realm"`
}

func (q *Queries) Wfschemadelete(ctx context.Context, arg WfschemadeleteParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, wfschemadelete,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
        )
        return err
}</span>

const wfschemaget = `-- name: Wfschemaget :one
SELECT s.slice, s.app, s.class, rm.longname, s.patternschema, s.actionschema, s.createdat, s.createdby, s.editedat, s.editedby
FROM schema as s, realm as rm, realmslice as rs
WHERE
    s.realm = rm.shortname
    and rs.realm = rm.shortname
    and s.slice = rs.id
    and s.slice = $1
    and rm.shortname = $4
    and s.class = $3
    AND s.app = $2
`

type WfschemagetParams struct {
        Slice int32  `json:"slice"`
        App   string `json:"app"`
        Class string `json:"class"`
        Realm string `json:"realm"`
}

type WfschemagetRow struct {
        Slice         int32            `json:"slice"`
        App           string           `json:"app"`
        Class         string           `json:"class"`
        Longname      string           `json:"longname"`
        Patternschema []byte           `json:"patternschema"`
        Actionschema  []byte           `json:"actionschema"`
        Createdat     pgtype.Timestamp `json:"createdat"`
        Createdby     string           `json:"createdby"`
        Editedat      pgtype.Timestamp `json:"editedat"`
        Editedby      pgtype.Text      `json:"editedby"`
}

func (q *Queries) Wfschemaget(ctx context.Context, arg WfschemagetParams) (WfschemagetRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, wfschemaget,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Realm,
        )
        var i WfschemagetRow
        err := row.Scan(
                &amp;i.Slice,
                &amp;i.App,
                &amp;i.Class,
                &amp;i.Longname,
                &amp;i.Patternschema,
                &amp;i.Actionschema,
                &amp;i.Createdat,
                &amp;i.Createdby,
                &amp;i.Editedat,
                &amp;i.Editedby,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package sqlc

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

// DBQuerier defines all functions to execute db queries and transactions
type DBQuerier interface {
        PerformDBOperationWithTX(ctx context.Context, queries func(Querier) (any, error)) (any, error)
        Querier
}

// QuerierTX provides all functions to execute SQL queries and transactions
type QuerierTX struct {
        connPool *pgxpool.Pool
        *Queries
}

/*
NewQuerierWithTX creates a new QuerierTX object
and returns QuerierWithTX interface
*/
func NewQuerierWithTX(connPool *pgxpool.Pool) DBQuerier <span class="cov0" title="0">{
        return &amp;QuerierTX{
                connPool: connPool,
                Queries:  New(connPool),
        }
}</span>

/*
PerformTX performs transaction operations for the queries callbackFunction
methods returns a result and error.PerformTx consist execTX methods which deals
with the transaction commit and rollback logic
*/
func (tx *QuerierTX) PerformDBOperationWithTX(ctx context.Context, queries func(Querier) (any, error)) (any, error) <span class="cov0" title="0">{
        return tx.execTX(ctx, queries)
}</span>

/*
execTX performs transaction commit and rollBack for the seeded
queryCallBack function arguments.execTX will return a result and error Based
on the transaction behavior
*/
func (qtx *QuerierTX) execTX(ctx context.Context, queryCallBack func(Querier) (any, error)) (any, error) <span class="cov0" title="0">{
        tx, err := qtx.connPool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">q := New(tx)
        result, err := queryCallBack(q)
        if err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
                }</span>
                <span class="cov0" title="0">return result, err</span>
        }
        <span class="cov0" title="0">return result, tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: stepworkflow.sql

package sqlc

import (
        "context"
)

const getWorkflow = `-- name: GetWorkflow :many
SELECT workflow, step FROM stepworkflow WHERE step = $1
`

type GetWorkflowRow struct {
        Workflow string `json:"workflow"`
        Step     string `json:"step"`
}

func (q *Queries) GetWorkflow(ctx context.Context, step string) ([]GetWorkflowRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getWorkflow, step)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []GetWorkflowRow
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetWorkflowRow
                if err := rows.Scan(&amp;i.Workflow, &amp;i.Step); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: wfinstance.sql

package sqlc

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const addWFNewInstances = `-- name: AddWFNewInstances :many
INSERT INTO
    wfinstance (
        entityid, slice, app, class, workflow, step, loggedat, nextstep, parent
    )
VALUES (
        $1, $2, $3, $4, $5, unnest($6::text []), (NOW()::timestamp), $7, $8
    )
RETURNING id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent
`

type AddWFNewInstancesParams struct {
        Entityid string      `json:"entityid"`
        Slice    int32       `json:"slice"`
        App      string      `json:"app"`
        Class    string      `json:"class"`
        Workflow string      `json:"workflow"`
        Step     []string    `json:"step"`
        Nextstep string      `json:"nextstep"`
        Parent   pgtype.Int4 `json:"parent"`
}

func (q *Queries) AddWFNewInstances(ctx context.Context, arg AddWFNewInstancesParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, addWFNewInstances,
                arg.Entityid,
                arg.Slice,
                arg.App,
                arg.Class,
                arg.Workflow,
                arg.Step,
                arg.Nextstep,
                arg.Parent,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const deleteWFInstanceListByParents = `-- name: DeleteWFInstanceListByParents :many
DELETE FROM wfinstance
WHERE 
   ($1::INTEGER[] IS NOT NULL AND id = ANY($1::INTEGER[]) OR $2::INTEGER[] IS NOT NULL AND parent = ANY($2::INTEGER[]))
    RETURNING id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent
`

type DeleteWFInstanceListByParentsParams struct {
        ID     []int32 `json:"id"`
        Parent []int32 `json:"parent"`
}

func (q *Queries) DeleteWFInstanceListByParents(ctx context.Context, arg DeleteWFInstanceListByParentsParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, deleteWFInstanceListByParents, arg.ID, arg.Parent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const deleteWfinstanceByID = `-- name: DeleteWfinstanceByID :many
  DELETE FROM wfinstance
   WHERE
       (id = $1::INTEGER OR entityid = $2::TEXT)
   RETURNING id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent
`

type DeleteWfinstanceByIDParams struct {
        ID       pgtype.Int4 `json:"id"`
        Entityid pgtype.Text `json:"entityid"`
}

func (q *Queries) DeleteWfinstanceByID(ctx context.Context, arg DeleteWfinstanceByIDParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, deleteWfinstanceByID, arg.ID, arg.Entityid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getWFINstance = `-- name: GetWFINstance :one
SELECT count(1)
FROM wfinstance
WHERE
    slice = $1
    AND app = $2
    AND workflow = $3
    AND entityid = $4
`

type GetWFINstanceParams struct {
        Slice    int32  `json:"slice"`
        App      string `json:"app"`
        Workflow string `json:"workflow"`
        Entityid string `json:"entityid"`
}

func (q *Queries) GetWFINstance(ctx context.Context, arg GetWFINstanceParams) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWFINstance,
                arg.Slice,
                arg.App,
                arg.Workflow,
                arg.Entityid,
        )
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const getWFInstanceList = `-- name: GetWFInstanceList :many
SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent FROM wfinstance
WHERE 
   ($1::INTEGER is null OR slice = $1::INTEGER)
   AND ($2::text is null OR entityid = $2::text)
   AND ($3::text is null OR app = $3::text)
   AND ($4::text is null OR workflow = $4::text)
   AND($5::INTEGER is null OR  parent = $5::INTEGER)
`

type GetWFInstanceListParams struct {
        Slice    pgtype.Int4 `json:"slice"`
        Entityid pgtype.Text `json:"entityid"`
        App      pgtype.Text `json:"app"`
        Workflow pgtype.Text `json:"workflow"`
        Parent   pgtype.Int4 `json:"parent"`
}

func (q *Queries) GetWFInstanceList(ctx context.Context, arg GetWFInstanceListParams) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getWFInstanceList,
                arg.Slice,
                arg.Entityid,
                arg.App,
                arg.Workflow,
                arg.Parent,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getWFInstanceListByParents = `-- name: GetWFInstanceListByParents :many
SELECT id, entityid, slice, app, class, workflow, step, loggedat, doneat, nextstep, parent FROM wfinstance
WHERE 
   ($1::INTEGER[] IS NOT NULL AND id = ANY($1::INTEGER[]))
`

func (q *Queries) GetWFInstanceListByParents(ctx context.Context, id []int32) ([]Wfinstance, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getWFInstanceListByParents, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Wfinstance
        for rows.Next() </span><span class="cov0" title="0">{
                var i Wfinstance
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Entityid,
                        &amp;i.Slice,
                        &amp;i.App,
                        &amp;i.Class,
                        &amp;i.Workflow,
                        &amp;i.Step,
                        &amp;i.Loggedat,
                        &amp;i.Doneat,
                        &amp;i.Nextstep,
                        &amp;i.Parent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package crux

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "github.com/remiges-tech/crux/db/sqlc-gen"
)

func loadInternalSchema(dbResponseSchema []sqlc.Schema) error <span class="cov0" title="0">{

        if len(dbResponseSchema) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dbResponseRuleSet is empty")
        }</span>

        <span class="cov0" title="0">for _, row := range dbResponseSchema </span><span class="cov0" title="0">{
                realmKey := realm_t(row.Realm)
                perRealm, exists := schemaCache[realmKey]
                if !exists </span><span class="cov0" title="0">{
                        perRealm = make(perRealm_t)
                        schemaCache[realmKey] = perRealm
                }</span>

                <span class="cov0" title="0">appKey := app_t(row.App)
                perApp, exists := perRealm[appKey]
                if !exists </span><span class="cov0" title="0">{
                        perApp = make(perApp_t)
                        perRealm[appKey] = perApp
                }</span>

                <span class="cov0" title="0">sliceKey := slice_t(row.Slice)
                _, exists = perApp[sliceKey]
                if !exists </span><span class="cov0" title="0">{
                        perApp[sliceKey] = perSlice_t{
                                LoadedAt: time.Now(),
                                BRSchema: make(map[className_t][]*Schema_t),
                                WFSchema: make(map[className_t][]*Schema_t),
                        }

                        var patterns []PatternSchema_t

                        if err := json.Unmarshal(row.Patternschema, &amp;patterns); err != nil </span><span class="cov0" title="0">{
                                log.Println("Error unmarshaling Patternschema:", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">var actions ActionSchema_t

                        if err := json.Unmarshal(row.Actionschema, &amp;actions); err != nil </span><span class="cov0" title="0">{
                                log.Println("Error parsing ActionSchema JSON:", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">schemaData := &amp;Schema_t{
                                Class:         row.Class,
                                PatternSchema: patterns,
                                ActionSchema:  actions,
                        }

                        classNameKey := className_t(row.Class)
                        if row.Brwf == "B" </span><span class="cov0" title="0">{
                                perApp[sliceKey].BRSchema[classNameKey] = append(perApp[sliceKey].BRSchema[classNameKey], schemaData)
                        }</span> else<span class="cov0" title="0"> if row.Brwf == "W" </span><span class="cov0" title="0">{
                                perApp[sliceKey].WFSchema[classNameKey] = append(perApp[sliceKey].WFSchema[classNameKey], schemaData)
                        }</span>

                }
        }
        <span class="cov0" title="0">return nil</span>
}

func loadInternalRuleSet(dbResponseRuleSet []sqlc.Ruleset) error <span class="cov0" title="0">{

        if len(dbResponseRuleSet) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dbResponseRuleSet is empty")
        }</span>
        <span class="cov0" title="0">for _, row := range dbResponseRuleSet </span><span class="cov0" title="0">{

                realmKey := realm_t(row.Realm)
                perRealm, exists := rulesetCache[realmKey]
                if !exists </span><span class="cov0" title="0">{
                        perRealm = make(perRealm_t)
                        rulesetCache[realmKey] = perRealm
                }</span>

                <span class="cov0" title="0">appKey := app_t(row.App)
                perApp, exists := perRealm[appKey]
                if !exists </span><span class="cov0" title="0">{
                        perApp = make(perApp_t)
                        perRealm[appKey] = perApp
                }</span>

                <span class="cov0" title="0">sliceKey := slice_t(row.Slice)
                _, exists = perApp[sliceKey]
                if !exists </span><span class="cov0" title="0">{
                        perApp[sliceKey] = perSlice_t{
                                LoadedAt:   time.Now(),
                                BRRulesets: make(map[className_t][]*Ruleset_t),
                                Workflows:  make(map[className_t][]*Ruleset_t),
                        }

                        var rules []Rule_t

                        err := json.Unmarshal(row.Ruleset, &amp;rules)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("Error unmarshaling rules:", err)
                                return nil
                        }</span>

                        <span class="cov0" title="0">classNameKey := className_t(row.Setname)
                        newRuleset := &amp;Ruleset_t{
                                Id:      row.ID,
                                Class:   row.Class,
                                SetName: row.Setname,
                                Rules:   rules,
                        }
                        if row.Brwf == "B" </span><span class="cov0" title="0">{
                                perApp[sliceKey].BRRulesets[classNameKey] = append(perApp[sliceKey].BRRulesets[classNameKey], newRuleset)

                        }</span> else<span class="cov0" title="0"> if row.Brwf == "W" </span><span class="cov0" title="0">{
                                perApp[sliceKey].Workflows[classNameKey] = append(perApp[sliceKey].Workflows[classNameKey], newRuleset)
                        }</span>

                }
        }
        <span class="cov0" title="0">AddReferencesToRuleSetCache()
        return nil</span>
}
func loadInternal(dbResponseSchema []sqlc.Schema, dbResponseRuleSet []sqlc.Ruleset) error <span class="cov0" title="0">{
        rulesetCache = make(rulesetCache_t)
        schemaCache = make(schemaCache_t)

        err := loadInternalSchema(dbResponseSchema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = loadInternalRuleSet(dbResponseRuleSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func purgeInternal() error <span class="cov0" title="0">{
        rulesetCache = make(rulesetCache_t)
        schemaCache = make(schemaCache_t)
        return nil

}</span>

func Load(query sqlc.DBQuerier, ctx context.Context) error <span class="cov0" title="0">{

        lockCache()
        defer unlockCache()

        dbResponseSchema, err := query.AllSchemas(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dbResponseRuleSet, err := query.AllRuleset(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = loadInternal(dbResponseSchema, dbResponseRuleSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func Purge() error <span class="cov0" title="0">{
        lockCache()
        defer unlockCache()

        if err := purgeInternal(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to purge data from cache:", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func Reload(query sqlc.DBQuerier, ctx context.Context) error <span class="cov0" title="0">{
        lockCache()
        defer unlockCache()

        if err := purgeInternal(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to purge data from cache:", err)
                return err
        }</span>

        <span class="cov0" title="0">dbResponseSchema, err := query.AllSchemas(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dbResponseRuleSet, err := query.AllRuleset(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = loadInternal(dbResponseSchema, dbResponseRuleSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package crux

import (
        "reflect"
        "sync"
        "time"
)

type realm_t string
type app_t string
type slice_t int
type className_t string
type BrwfEnum string

const (
        valInt_t valType_t = iota
        valFloat_t
        valString_t
        valBool_t
        valTimestamp_t
        valEnum_t
)

type perSlice_t struct {
        LoadedAt   time.Time
        BRSchema   map[className_t][]*Schema_t
        BRRulesets map[className_t][]*Ruleset_t
        WFSchema   map[className_t][]*Schema_t
        Workflows  map[className_t][]*Ruleset_t
}

type Schema_t struct {
        Class         string            `json:"class"`
        PatternSchema []PatternSchema_t `json:"patternschema"`
        ActionSchema  ActionSchema_t    `json:"actionschema"`
        NChecked      int32             `json:"n_checked"`
}
type PatternSchema_t struct {
        Attr      string              `json:"attr" validate:"required"`
        ShortDesc string              `json:"shortdesc" validate:"required"`
        LongDesc  string              `json:"longdesc" validate:"required"`
        ValType   string              `json:"valtype" validate:"required"`
        EnumVals  map[string]struct{} `json:"vals,omitempty"`
        ValMin    float64             `json:"valmin,omitempty"`
        ValMax    float64             `json:"valmax,omitempty"`
        LenMin    int                 `json:"lenmin,omitempty"`
        LenMax    int                 `json:"lenmax,omitempty"`
}

type valType_t int

const (
        valInt valType_t = iota
        valFloat
        valString
        valBool
        valTimestamp
        valEnum
)

type ActionSchema_t struct {
        Tasks      []string `json:"tasks" validate:"required"`
        Properties []string `json:"properties" validate:"required"`
}

type ruleOp_t int

const (
        ruleOpEQ ruleOp_t = iota // Equal to
        ruleOpNE                 // Not equal to
        ruleOpGT                 // Greater than
        ruleOpGE                 // Greater than or equal to
        ruleOpLT                 // Less than
        ruleOpLE                 // Less than or equal to
)

type RulePatternBlock_t struct {
        Attr string `json:"attr" validate:"required"`
        Op   string `json:"op" validate:"required"`
        Val  any    `json:"val" validate:"required"`
}

type RuleActionBlock_t struct {
        Task          []string          `json:"tasks" validate:"required"`
        Properties    map[string]string `json:"properties" validate:"required"`
        ThenCall      string            `json:"thencall,omitempty"`
        ElseCall      string            `json:"elsecall,omitempty"`
        DoReturn      bool              `json:"doreturn,omitempty"`
        DoExit        bool              `json:"doexit,omitempty"`
        References    []*Ruleset_t      `json:"-"`
        ReferenceType string            `json:"referencetype,omitempty"`
}

type Rule_t struct {
        RulePatterns []RulePatternBlock_t `json:"rulepattern" validate:"required,dive"`
        RuleActions  RuleActionBlock_t    `json:"ruleactions" validate:"required"`
        NMatched     int32
        NFailed      int32
}

type Ruleset_t struct {
        Id            int32    `json:"id"`
        Class         string   `json:"class"`
        SetName       string   `json:"setname"`
        Rules         []Rule_t `json:"rule"`
        NCalled       int32
        ReferenceType string
}

type perApp_t map[slice_t]perSlice_t

type perRealm_t map[app_t]perApp_t

type rulesetCache_t map[realm_t]perRealm_t

type schemaCache_t map[realm_t]perRealm_t

var (
        rulesetCache rulesetCache_t
        schemaCache  schemaCache_t
        cacheLock    sync.RWMutex
)

func (a ActionSchema_t) IsEmpty() bool <span class="cov0" title="0">{
        return reflect.DeepEqual(a, ActionSchema_t{})
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package crux

import (
        "errors"
        "time"
)

type rulesetStats_t map[realm_t]statsPerRealm_t

type statsPerRealm_t map[app_t]statsPerApp_t

type statsPerApp_t map[slice_t]statsPerSlice_t

type statsPerSlice_t struct {
        loadedAt   time.Time
        BRSchema   map[className_t]statsSchema_t
        BRRulesets map[className_t][]statsRuleset_t
        WFSchema   map[className_t]statsSchema_t
        Workflows  map[className_t][]statsRuleset_t
}

type statsSchema_t struct {
        nChecked int32
}

type statsRuleset_t struct {
        nCalled    int32
        rulesStats []statsRule_t
}

type statsRule_t struct {
        nMatched int32
        nFailed  int32
}

func getStats(realm realm_t, app app_t, slice slice_t) (rulesetStats_t, time.Time, error) <span class="cov0" title="0">{
        var timestamp time.Time
        var err error

        statsData := make(rulesetStats_t)

        perRealm, realmExists := rulesetCache[realm]
        if !realmExists </span><span class="cov0" title="0">{
                return nil, timestamp, errors.New("Realm not found")
        }</span>
        <span class="cov0" title="0">perApp, appExists := perRealm[app]
        if !appExists </span><span class="cov0" title="0">{
                return nil, timestamp, errors.New("App not found")
        }</span>
        <span class="cov0" title="0">perSlice, sliceExists := perApp[slice]
        if !sliceExists </span><span class="cov0" title="0">{
                return nil, timestamp, errors.New("Slice not found")
        }</span>
        <span class="cov0" title="0">timestamp = perSlice.LoadedAt
        statsPerSlice := statsPerSlice_t{
                loadedAt:   perSlice.LoadedAt,
                BRSchema:   make(map[className_t]statsSchema_t),
                BRRulesets: make(map[className_t][]statsRuleset_t),
                WFSchema:   make(map[className_t]statsSchema_t),
                Workflows:  make(map[className_t][]statsRuleset_t),
        }

        if schemaData, exists := schemaCache[realm][app][slice]; exists </span><span class="cov0" title="0">{
                for className, schemas := range schemaData.BRSchema </span><span class="cov0" title="0">{
                        for _, schema := range schemas </span><span class="cov0" title="0">{
                                statsPerSlice.BRSchema[className] = statsSchema_t{nChecked: schema.NChecked}

                        }</span>
                }
                <span class="cov0" title="0">for className, schemas := range schemaData.WFSchema </span><span class="cov0" title="0">{
                        for _, schema := range schemas </span><span class="cov0" title="0">{
                                statsPerSlice.WFSchema[className] = statsSchema_t{nChecked: schema.NChecked}

                        }</span>
                }
        }
        <span class="cov0" title="0">if rulesetData, exists := rulesetCache[realm][app][slice]; exists </span><span class="cov0" title="0">{
                for className, rulesets := range rulesetData.BRRulesets </span><span class="cov0" title="0">{
                        statsPerSlice.BRRulesets[className] = make([]statsRuleset_t, len(rulesets))
                        for i, ruleset := range rulesets </span><span class="cov0" title="0">{
                                statsPerSlice.BRRulesets[className][i] = statsRuleset_t{
                                        nCalled:    ruleset.NCalled,
                                        rulesStats: make([]statsRule_t, len(ruleset.Rules)),
                                }
                                for j, rule := range ruleset.Rules </span><span class="cov0" title="0">{
                                        statsPerSlice.BRRulesets[className][i].rulesStats[j] = statsRule_t{
                                                nMatched: rule.NMatched,
                                                nFailed:  rule.NFailed,
                                        }
                                }</span>
                        }
                }
                <span class="cov0" title="0">for className, rulesets := range rulesetData.Workflows </span><span class="cov0" title="0">{
                        statsPerSlice.Workflows[className] = make([]statsRuleset_t, len(rulesets))
                        for i, ruleset := range rulesets </span><span class="cov0" title="0">{
                                statsPerSlice.Workflows[className][i] = statsRuleset_t{
                                        nCalled:    ruleset.NCalled,
                                        rulesStats: make([]statsRule_t, len(ruleset.Rules)),
                                }
                                for j, rule := range ruleset.Rules </span><span class="cov0" title="0">{
                                        statsPerSlice.Workflows[className][i].rulesStats[j] = statsRule_t{
                                                nMatched: rule.NMatched,
                                                nFailed:  rule.NFailed,
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">statsPerApp := make(statsPerApp_t)
        statsPerApp[slice] = statsPerSlice

        statsPerRealm := make(statsPerRealm_t)
        statsPerRealm[app] = statsPerApp

        statsData[realm] = statsPerRealm

        return statsData, timestamp, err</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package crux

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "reflect"
        "strconv"
        "testing"
        "time"

        "github.com/remiges-tech/crux/db/sqlc-gen"

        "github.com/jackc/pgx/v5/pgxpool"
)

func lockCache() <span class="cov0" title="0">{
        cacheLock.Lock()
}</span>

func unlockCache() <span class="cov0" title="0">{
        cacheLock.Unlock()
}</span>

func NewProvider(cfg string) sqlc.DBQuerier <span class="cov0" title="0">{
        ctx := context.Background()
        db, err := pgxpool.New(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error connecting db")
        }</span>
        <span class="cov0" title="0">err = db.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">log.Println("Successfully connected to the database")
        return sqlc.NewQuerierWithTX(db)</span>
}

func AddReferencesToRuleSetCache() <span class="cov0" title="0">{
        for realmKey, perRealm := range rulesetCache </span><span class="cov0" title="0">{
                for _, perApp := range perRealm </span><span class="cov0" title="0">{
                        for sliceKey, perSlice := range perApp </span><span class="cov0" title="0">{
                                for _, rulesets := range perSlice.BRRulesets </span><span class="cov0" title="0">{
                                        for _, rule := range rulesets </span><span class="cov0" title="0">{
                                                for _, subRule := range rule.Rules </span><span class="cov0" title="0">{
                                                        if subRule.RuleActions.ThenCall != "" </span><span class="cov0" title="0">{
                                                                searchAndAddReferences(subRule.RuleActions.ThenCall, rulesetCache, realmKey, sliceKey, rule, "thencall", subRule)
                                                        }</span>
                                                        <span class="cov0" title="0">if subRule.RuleActions.ElseCall != "" </span><span class="cov0" title="0">{
                                                                searchAndAddReferences(subRule.RuleActions.ElseCall, rulesetCache, realmKey, sliceKey, rule, "elsecall", subRule)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }
}

func searchAndAddReferences(targetSetName string, cache map[realm_t]perRealm_t, realmKey realm_t,
        sliceKey slice_t, sourceRule *Ruleset_t, calltype string, subRule Rule_t) <span class="cov0" title="0">{
        for _, perApp := range cache[realmKey] </span><span class="cov0" title="0">{
                for otherSliceKey, perSlice := range perApp </span><span class="cov0" title="0">{
                        if otherSliceKey == sliceKey </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, existingRulesets := range perSlice.BRRulesets </span><span class="cov0" title="0">{
                                for _, existingRule := range existingRulesets </span><span class="cov0" title="0">{
                                        if existingRule.SetName == targetSetName </span><span class="cov0" title="0">{
                                                existingRule.ReferenceType = calltype
                                                sourceRule.Rules[0].RuleActions.References = append(sourceRule.Rules[0].RuleActions.References, existingRule)

                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">for _, existingRulesets := range perSlice.Workflows </span><span class="cov0" title="0">{
                                for _, existingRule := range existingRulesets </span><span class="cov0" title="0">{
                                        if existingRule.SetName == targetSetName </span><span class="cov0" title="0">{
                                                existingRule.ReferenceType = calltype
                                                sourceRule.Rules[0].RuleActions.References = append(sourceRule.Rules[0].RuleActions.References, existingRule)

                                        }</span>
                                }
                        }
                }
        }
}

func PrintAllRuleSetCache() <span class="cov0" title="0">{
        for realmKey, perRealm := range rulesetCache </span><span class="cov0" title="0">{
                fmt.Println("Realm:", realmKey)
                for appKey, perApp := range perRealm </span><span class="cov0" title="0">{
                        fmt.Println("\tApp:", appKey)
                        for sliceKey, perSlice := range perApp </span><span class="cov0" title="0">{
                                fmt.Println("\t\tSlice:", sliceKey)
                                fmt.Println("\t\t\tLoadedAt:", perSlice.LoadedAt)

                                // Print BRRulesets

                                for className, rulesets := range perSlice.BRRulesets </span><span class="cov0" title="0">{
                                        fmt.Println("\t\t\tBRRulesets - Class:", className)
                                        for _, rule := range rulesets </span><span class="cov0" title="0">{
                                                for _, t := range rule.Rules </span><span class="cov0" title="0">{
                                                        fmt.Println("\t\t\t\tRulePatterns:", t.RulePatterns)
                                                        fmt.Println("\t\t\t\tRuleActions:", t.RuleActions)
                                                        fmt.Println("\t\t\t\tNMatched:", t.NMatched)
                                                        fmt.Println("\t\t\t\tNFailed:", rule.Rules[0].NFailed)

                                                        // Print References if available
                                                        for _, reference := range rule.Rules[0].RuleActions.References </span><span class="cov0" title="0">{
                                                                fmt.Println("\t\t\t\t\tReferenced Rule:")
                                                                fmt.Println("\t\t\t\t\t\tRulePatterns:", reference.Rules[0].RulePatterns)
                                                                fmt.Println("\t\t\t\t\t\tRuleActions:", reference.Rules[0].RuleActions)
                                                                fmt.Println("\t\t\t\t\t\tNMatched:", reference.Rules[0].NMatched)
                                                                fmt.Println("\t\t\t\t\t\tNFailed:", reference.Rules[0].NFailed)
                                                        }</span>
                                                }
                                        }
                                }

                                // Print Workflows
                                <span class="cov0" title="0">for className, workflows := range perSlice.Workflows </span><span class="cov0" title="0">{
                                        fmt.Println("\t\t\tWorkflows - Class:", className)
                                        for _, workflow := range workflows </span><span class="cov0" title="0">{
                                                fmt.Println("\t\t\t\tRulePatterns:", workflow.Rules[0].RulePatterns)
                                                fmt.Println("\t\t\t\tRuleActions:", workflow.Rules[0].RuleActions)
                                                fmt.Println("\t\t\t\tNMatched:", workflow.Rules[0].NMatched)
                                                fmt.Println("\t\t\t\tNFailed:", workflow.Rules[0].NFailed)

                                                // Print References if available
                                                for _, reference := range workflow.Rules[0].RuleActions.References </span><span class="cov0" title="0">{
                                                        fmt.Println("\t\t\t\t\tReferenced Rule:")
                                                        fmt.Println("\t\t\t\t\t\tRulePatterns:", reference.Rules[0].RulePatterns)
                                                        fmt.Println("\t\t\t\t\t\tRuleActions:", reference.Rules[0].RuleActions)
                                                        fmt.Println("\t\t\t\t\t\tNMatched:", reference.Rules[0].NMatched)
                                                        fmt.Println("\t\t\t\t\t\tNFailed:", reference.Rules[0].NFailed)
                                                }</span>
                                        }
                                }
                        }
                }
        }
}
func PrintAllSchemaCache() <span class="cov0" title="0">{

        for realmKey, perRealm := range schemaCache </span><span class="cov0" title="0">{
                fmt.Println("Realm:", realmKey)
                for appKey, perApp := range perRealm </span><span class="cov0" title="0">{
                        fmt.Println("\tApp:", appKey)
                        for sliceKey, perSlice := range perApp </span><span class="cov0" title="0">{
                                fmt.Println("\t\tSlice:", sliceKey)
                                fmt.Println("\t\t\tLoadedAt:", perSlice.LoadedAt)
                                for className, schemas := range perSlice.BRSchema </span><span class="cov0" title="0">{
                                        fmt.Println("\t\t\tBRSchema - Class:", className)
                                        for _, schema := range schemas </span><span class="cov0" title="0">{
                                                fmt.Println("\t\t\t\tPatternSchema:", schema.PatternSchema)
                                                fmt.Println("\t\t\t\tActionSchema:", schema.ActionSchema)
                                                fmt.Println("\t\t\t\tNChecked:", schema.NChecked)
                                        }</span>
                                }
                                <span class="cov0" title="0">for className, schemas := range perSlice.WFSchema </span><span class="cov0" title="0">{
                                        fmt.Println("\t\t\tWFSchema - Class:", className)
                                        for _, schema := range schemas </span><span class="cov0" title="0">{
                                                fmt.Println("\t\t\t\tPatternSchema:", schema.PatternSchema)
                                                fmt.Println("\t\t\t\tActionSchema:", schema.ActionSchema)
                                                fmt.Println("\t\t\t\tNChecked:", schema.NChecked)
                                        }</span>
                                }

                        }
                }
        }

}

func containsField(value interface{}, fieldName string, t *testing.T) bool <span class="cov0" title="0">{

        switch v := value.(type) </span>{

        case []byte:<span class="cov0" title="0">

                var raw json.RawMessage
                if err := json.Unmarshal(v, &amp;raw); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error unmarshalling actual pattern:", err, v)
                        return false
                }</span>

                <span class="cov0" title="0">var data map[string]interface{}
                if err := json.Unmarshal(raw, &amp;data); err != nil </span><span class="cov0" title="0">{
                        var arrayData []interface{}
                        if err := json.Unmarshal(raw, &amp;arrayData); err != nil </span><span class="cov0" title="0">{
                                fmt.Println("Error unmarshalling actual pattern:", err, v)
                                return false
                        }</span>
                        <span class="cov0" title="0">for _, element := range arrayData </span><span class="cov0" title="0">{
                                if containsFieldName(element, fieldName) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov0" title="0">for _, value := range data </span><span class="cov0" title="0">{
                        if containsFieldName(value, fieldName) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        case map[string]interface{}:<span class="cov0" title="0">

                for key := range v </span><span class="cov0" title="0">{
                        if key == fieldName </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

        case []interface{}:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if containsField(item, fieldName, t) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        case string:<span class="cov0" title="0">
                return v == fieldName</span>
        }
        <span class="cov0" title="0">return false</span>
}

func containsFieldName(value interface{}, fieldName string) bool <span class="cov0" title="0">{

        v := reflect.ValueOf(value)

        switch v.Kind() </span>{
        case reflect.Map:<span class="cov0" title="0">
                for _, key := range v.MapKeys() </span><span class="cov0" title="0">{
                        if key.Kind() == reflect.String &amp;&amp; key.String() == fieldName </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">if nestedValue := v.MapIndex(key).Interface(); containsFieldName(nestedValue, fieldName) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

        case reflect.Slice:<span class="cov0" title="0">
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        if nestedValue := v.Index(i).Interface(); containsFieldName(nestedValue, fieldName) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        case reflect.String:<span class="cov0" title="0">
                return value.(string) == fieldName</span>
        }
        <span class="cov0" title="0">return false</span>
}
func retrieveSchemasFromCacheByte(realm string, app string, class string, slice int, brwf string) ([]byte, []byte, string) <span class="cov0" title="0">{
        realmKey := realm_t(realm)
        perRealm, realmExists := schemaCache[realmKey]
        if !realmExists </span><span class="cov0" title="0">{
                return nil, nil, "Realmkey not match"
        }</span>

        <span class="cov0" title="0">appKey := app_t(app)
        perApp, appExists := perRealm[appKey]
        if !appExists </span><span class="cov0" title="0">{
                return nil, nil, "AppKey not match"
        }</span>

        <span class="cov0" title="0">sliceKey := slice_t(slice)
        perSlice, sliceExists := perApp[sliceKey]
        if !sliceExists </span><span class="cov0" title="0">{
                return nil, nil, "Slice key not match"
        }</span>

        <span class="cov0" title="0">classNameKey := className_t(class)
        var schemas []*Schema_t

        if brwf == "B" </span><span class="cov0" title="0">{
                schemas = perSlice.BRSchema[classNameKey]
        }</span> else<span class="cov0" title="0"> if brwf == "W" </span><span class="cov0" title="0">{
                schemas = perSlice.WFSchema[classNameKey]
        }</span>

        <span class="cov0" title="0">if len(schemas) == 0 </span><span class="cov0" title="0">{
                return nil, nil, "No schemas found for the given class"
        }</span>

        <span class="cov0" title="0">if len(schemas) == 0 </span><span class="cov0" title="0">{
                return nil, nil, "No schemas found for the given class"
        }</span>

        <span class="cov0" title="0">patternSchemaJSON, err := json.Marshal(schemas[0].PatternSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, "JSON failed to marshal pattern"
        }</span>

        <span class="cov0" title="0">actionSchemaJSON, err := json.Marshal(schemas[0].ActionSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, "JSON failed to marshal action"
        }</span>

        <span class="cov0" title="0">return patternSchemaJSON, actionSchemaJSON, "success"</span>
}

func retrieveRulesetFromCacheByte(realm string, app string, class string, slice int,
        brwf string) ([]byte, []byte, string, []*Ruleset_t) <span class="cov0" title="0">{
        realmKey := realm_t(realm)
        perRealm, exists := rulesetCache[realmKey]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil, "Realmkey not match", nil
        }</span>

        <span class="cov0" title="0">appKey := app_t(app)
        perApp, exists := perRealm[appKey]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil, "AppKey not match", nil
        }</span>

        <span class="cov0" title="0">sliceKey := slice_t(slice)
        perSlice, exists := perApp[sliceKey]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil, "Slice key not match", nil
        }</span>

        <span class="cov0" title="0">classNameKey := className_t(class)
        brwfKey := BrwfEnum(brwf)
        var rulesets []*Ruleset_t

        if brwfKey == "B" </span><span class="cov0" title="0">{
                rulesets = perSlice.BRRulesets[classNameKey]
        }</span> else<span class="cov0" title="0"> {
                rulesets = perSlice.Workflows[classNameKey]
        }</span>

        <span class="cov0" title="0">if len(rulesets) == 0 </span><span class="cov0" title="0">{
                return nil, nil, "No rulesets found for the given class", nil
        }</span>

        <span class="cov0" title="0">ruleset := rulesets[0]

        RuleActions, err := json.Marshal(ruleset.Rules[0].RuleActions)
        if err != nil </span><span class="cov0" title="0">{

                return nil, nil, "JSON failed to marshal rule actions", nil
        }</span>

        <span class="cov0" title="0">RulePatterns, err := json.Marshal(ruleset.Rules[0].RulePatterns)
        if err != nil </span><span class="cov0" title="0">{

                return nil, nil, "JSON failed to marshal rule patterns", nil
        }</span>

        <span class="cov0" title="0">return RulePatterns, RuleActions, "success", ruleset.Rules[0].RuleActions.References</span>

}

func retrieveRuleSchemasFromCache(realm string, app string, class string, slice int) ([]*Schema_t, error) <span class="cov0" title="0">{
        realmKey := realm_t(realm)

        perRealm, realmExists := schemaCache[realmKey]
        if !realmExists </span><span class="cov0" title="0">{

                return nil, errors.New("schema Realmkey not match")
        }</span>

        <span class="cov0" title="0">appKey := app_t(app)
        perApp, appExists := perRealm[appKey]
        if !appExists </span><span class="cov0" title="0">{

                return nil, errors.New("schema AppKey not match")
        }</span>

        <span class="cov0" title="0">sliceKey := slice_t(slice)

        perSlice, sliceExists := perApp[sliceKey]
        if !sliceExists </span><span class="cov0" title="0">{

                return nil, errors.New("schema Slice key not match")
        }</span>

        <span class="cov0" title="0">var ruleSchemas []*Schema_t

        brSchemas, brExists := perSlice.BRSchema[className_t(class)]
        if brExists </span><span class="cov0" title="0">{
                for _, schemas := range brSchemas </span><span class="cov0" title="0">{

                        ruleSchemas = append(ruleSchemas, schemas)
                }</span>
        }

        <span class="cov0" title="0">wfSchemas, wfExists := perSlice.WFSchema[className_t(class)]
        if wfExists </span><span class="cov0" title="0">{
                for _, schemas := range wfSchemas </span><span class="cov0" title="0">{
                        ruleSchemas = append(ruleSchemas, schemas)
                }</span>
        }

        <span class="cov0" title="0">return ruleSchemas, nil</span>
}
func convertAttrValue(entityAttrVal string, valType valType_t) any <span class="cov0" title="0">{

        var entityAttrValConv any
        var err error
        switch valType </span>{
        case valBool_t:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.ParseBool(entityAttrVal)</span>
        case valInt_t:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.Atoi(entityAttrVal)</span>
        case valFloat_t:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.ParseFloat(entityAttrVal, 64)</span>
        case valString_t, valEnum_t:<span class="cov0" title="0">
                entityAttrValConv = entityAttrVal</span>
        case valTimestamp_t:<span class="cov0" title="0">
                entityAttrValConv, err = time.Parse(timeLayout, entityAttrVal)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return entityAttrValConv</span>
}

func retrieveRuleSetsFromCache(realm string, app string, class string, slice int) ([]*Ruleset_t, error) <span class="cov0" title="0">{
        realmKey := realm_t(realm)

        perRealm, realmExists := rulesetCache[realmKey]
        if !realmExists </span><span class="cov0" title="0">{
                return nil, errors.New("ruleset realmkey not match")
        }</span>

        <span class="cov0" title="0">appKey := app_t(app)
        perApp, appExists := perRealm[appKey]
        if !appExists </span><span class="cov0" title="0">{
                return nil, errors.New("ruleset appKey not match")
        }</span>

        <span class="cov0" title="0">sliceKey := slice_t(slice)
        perSlice, sliceExists := perApp[sliceKey]
        if !sliceExists </span><span class="cov0" title="0">{
                return nil, errors.New("ruleset slice key not match")
        }</span>

        <span class="cov0" title="0">var ruleSets []*Ruleset_t

        for _, brRulesets := range perSlice.BRRulesets </span><span class="cov0" title="0">{
                ruleSets = append(ruleSets, brRulesets...)
        }</span>
        <span class="cov0" title="0">for _, wfRulesets := range perSlice.Workflows </span><span class="cov0" title="0">{
                ruleSets = append(ruleSets, wfRulesets...)
        }</span>

        <span class="cov0" title="0">return ruleSets, nil</span>
}

func retriveRuleSchemasAndRuleSetsFromCache(realm string, app string, class string, slice string) ([]*Schema_t, []*Ruleset_t) <span class="cov0" title="0">{
        s, _ := strconv.Atoi(slice)

        ruleSchemas, _ := retrieveRuleSchemasFromCache(realm, app, class, s)

        ruleSets, _ := retrieveRuleSetsFromCache(realm, app, class, s)
        return ruleSchemas, ruleSets

}</span>
func printStats(statsData rulesetStats_t) <span class="cov0" title="0">{
        for realm, perRealm := range statsData </span><span class="cov0" title="0">{
                for app, perApp := range perRealm </span><span class="cov0" title="0">{
                        for slice, perSlice := range perApp </span><span class="cov0" title="0">{
                                fmt.Printf("Realm: %v, App: %v, Slice: %v\n", realm, app, slice)
                                fmt.Printf("loadedAt: %v\n", perSlice.loadedAt)

                                // Print stats for BRSchema
                                for className, schema := range perSlice.BRSchema </span><span class="cov0" title="0">{
                                        fmt.Printf("Class: %v, nChecked: %v\n", className, schema.nChecked)
                                }</span>

                                // Print stats for BRRulesets
                                <span class="cov0" title="0">for className, rulesets := range perSlice.BRRulesets </span><span class="cov0" title="0">{
                                        for _, ruleset := range rulesets </span><span class="cov0" title="0">{
                                                fmt.Printf("Class: %v, nCalled: %v\n", className, ruleset.nCalled)
                                                for _, rule := range ruleset.rulesStats </span><span class="cov0" title="0">{
                                                        fmt.Printf("nMatched: %v, nFailed: %v\n", rule.nMatched, rule.nFailed)
                                                }</span>
                                        }
                                }

                                // Print stats for WFSchema
                                <span class="cov0" title="0">for className, schema := range perSlice.WFSchema </span><span class="cov0" title="0">{
                                        fmt.Printf("Class: %v, nChecked: %v\n", className, schema.nChecked)
                                }</span>

                                // Print stats for Workflows
                                <span class="cov0" title="0">for className, workflows := range perSlice.Workflows </span><span class="cov0" title="0">{
                                        for _, workflow := range workflows </span><span class="cov0" title="0">{
                                                fmt.Printf("Class: %v, nCalled: %v\n", className, workflow.nCalled)
                                                for _, rule := range workflow.rulesStats </span><span class="cov0" title="0">{
                                                        fmt.Printf("nMatched: %v, nFailed: %v\n", rule.nMatched, rule.nFailed)
                                                }</span>
                                        }
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/* This file contains the collectActions() function */

package crux

func collectActions(actionSet ActionSet, ruleActions RuleActionBlock_t) ActionSet <span class="cov0" title="0">{

        newActionSet := ActionSet{
                tasks:      []string{},
                properties: make(map[string]string),
        }

        // Union-set of tasks
        newActionSet.tasks = append(newActionSet.tasks, actionSet.tasks...)
        for _, newTask := range ruleActions.Task </span><span class="cov0" title="0">{
                found := false
                for _, task := range newActionSet.tasks </span><span class="cov0" title="0">{
                        if newTask == task </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        newActionSet.tasks = append(newActionSet.tasks, newTask)
                }</span>
        }

        // Perform "union-set" of properties, overwriting previous property values if needed

        <span class="cov0" title="0">for name, val := range actionSet.properties </span><span class="cov0" title="0">{
                newActionSet.properties[name] = val
        }</span>

        // Update properties from ruleActions
        <span class="cov0" title="0">for propName, propertyVal := range ruleActions.Properties </span><span class="cov0" title="0">{
                found := false
                for existingPropName := range newActionSet.properties </span><span class="cov0" title="0">{
                        if existingPropName == propName </span><span class="cov0" title="0">{
                                newActionSet.properties[existingPropName] = propertyVal
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        newActionSet.properties[propName] = propertyVal
                }</span>
        }

        <span class="cov0" title="0">return newActionSet</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
This file contains doMatch() and a helper function called by doMatch().

It also contains ruleSchemasCache and ruleSetsCache, two  variables that currently store rule-schemas
and rulesets respectively for the purpose of testing doMatch().
*/

package crux

import (
        "errors"
        "fmt"
)

func doMatch(entity Entity, ruleset *Ruleset_t, actionSet ActionSet, seenRuleSets map[string]struct{}) (ActionSet, bool, error) <span class="cov0" title="0">{

        ruleSchemasCache, ruleSetsCache := retriveRuleSchemasAndRuleSetsFromCache(entity.realm, entity.app, entity.class, entity.slice)

        if _, seen := seenRuleSets[ruleset.SetName]; seen </span><span class="cov0" title="0">{
                return ActionSet{
                        tasks:      []string{},
                        properties: make(map[string]string),
                }, false, errors.New("ruleset has already been traversed")
        }</span>

        <span class="cov0" title="0">seenRuleSets[ruleset.SetName] = struct{}{}

        for _, rule := range ruleset.Rules </span><span class="cov0" title="0">{

                DoExit := false

                matched, err := matchPattern(entity, rule.RulePatterns, actionSet, ruleSchemasCache)

                if err != nil </span><span class="cov0" title="0">{
                        return ActionSet{
                                tasks:      []string{},
                                properties: make(map[string]string),
                        }, false, err
                }</span>

                <span class="cov0" title="0">if matched </span><span class="cov0" title="0">{

                        actionSet = collectActions(actionSet, rule.RuleActions)

                        if len(rule.RuleActions.ThenCall) &gt; 0 </span><span class="cov0" title="0">{

                                setToCall, exists := findRuleSetByName(ruleSetsCache, rule.RuleActions.ThenCall)

                                if !exists </span><span class="cov0" title="0">{
                                        return ActionSet{}, false, errors.New("set not found")
                                }</span>

                                <span class="cov0" title="0">if setToCall.Class != entity.class </span><span class="cov0" title="0">{
                                        return inconsistentRuleSet(setToCall.SetName, ruleset.SetName, ruleset)
                                }</span>

                                <span class="cov0" title="0">var err error
                                actionSet, DoExit, err = doMatch(entity, setToCall, actionSet, seenRuleSets)
                                if err != nil </span><span class="cov0" title="0">{
                                        return ActionSet{
                                                tasks:      []string{},
                                                properties: make(map[string]string),
                                        }, false, err
                                }</span>
                        }

                        <span class="cov0" title="0">if DoExit || rule.RuleActions.DoExit </span><span class="cov0" title="0">{

                                return actionSet, true, nil
                        }</span>

                        <span class="cov0" title="0">if rule.RuleActions.DoReturn </span><span class="cov0" title="0">{

                                delete(seenRuleSets, ruleset.SetName)
                                return actionSet, false, nil
                        }</span>
                } else<span class="cov0" title="0"> if len(rule.RuleActions.ElseCall) &gt; 0 </span><span class="cov0" title="0">{

                        setToCall, exists := findRuleSetByName(ruleSetsCache, rule.RuleActions.ElseCall)
                        if !exists </span><span class="cov0" title="0">{
                                return ActionSet{}, false, errors.New("set not found")
                        }</span>

                        <span class="cov0" title="0">if setToCall.Class != entity.class </span><span class="cov0" title="0">{
                                return inconsistentRuleSet(setToCall.SetName, ruleset.SetName, ruleset)
                        }</span>

                        <span class="cov0" title="0">var err error
                        actionSet, DoExit, err = doMatch(entity, setToCall, actionSet, seenRuleSets)
                        if err != nil </span><span class="cov0" title="0">{
                                return ActionSet{
                                        tasks:      []string{},
                                        properties: make(map[string]string),
                                }, false, err
                        }</span> else<span class="cov0" title="0"> if DoExit </span><span class="cov0" title="0">{
                                return actionSet, true, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">delete(seenRuleSets, ruleset.SetName)

        return actionSet, false, nil</span>
}

func findRuleSetByName(ruleSets []*Ruleset_t, setName string) (*Ruleset_t, bool) <span class="cov0" title="0">{
        for _, ruleset := range ruleSets </span><span class="cov0" title="0">{
                if ruleset.SetName == setName </span><span class="cov0" title="0">{

                        ruleset.NCalled++
                        for _, rule := range ruleset.Rules </span><span class="cov0" title="0">{

                                rule.NMatched++

                        }</span>
                        <span class="cov0" title="0">return ruleset, true</span>
                } else<span class="cov0" title="0"> {

                        for _, rule := range ruleset.Rules </span><span class="cov0" title="0">{

                                rule.NFailed++

                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, false</span>
}

func inconsistentRuleSet(calledSetName string, currSetName string, ruleSets *Ruleset_t) (ActionSet, bool, error) <span class="cov0" title="0">{
        return ActionSet{}, false, fmt.Errorf("cannot call ruleset %v from ruleset %v",
                calledSetName, currSetName,
        )
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/* This file contains matchPattern(), and helper functions called by matchPattern() */

package crux

import (
        "errors"
        "fmt"
        "strconv"
        "time"
)

const (
        typeBool  = "bool"
        typeInt   = "int"
        typeFloat = "float"
        typeStr   = "str"
        typeEnum  = "enum"
        typeTS    = "ts"

        timeLayout = "2006-01-02T15:04:05Z"

        opEQ = "eq"
        opNE = "ne"
        opLT = "lt"
        opLE = "le"
        opGT = "gt"
        opGE = "ge"

        trueStr  = "true"
        falseStr = "false"
)

func matchPattern(entity Entity, rulePattern []RulePatternBlock_t, actionSet ActionSet, rSchema []*Schema_t) (bool, error) <span class="cov0" title="0">{

        for _, term := range rulePattern </span><span class="cov0" title="0">{
                valType := ""
                entityAttrVal := ""

                // Check whether the attribute name in the pattern term exists in the entity attrs map
                if val, ok := entity.attrs[term.Attr]; ok </span><span class="cov0" title="0">{

                        entityAttrVal = val
                        valType = getTypeFromSchema(entity.class, term.Attr, rSchema)
                        incrementStatsSchemaCounterNChecked(entity.class, rSchema)
                }</span>

                // If the attribute value is still empty, check whether it matches any of the tasks in the action-set
                <span class="cov0" title="0">if entityAttrVal == "" </span><span class="cov0" title="0">{
                        for _, task := range actionSet.tasks </span><span class="cov0" title="0">{
                                if task == term.Attr </span><span class="cov0" title="0">{
                                        entityAttrVal = trueStr
                                        valType = typeBool
                                }</span>
                        }
                }

                // If the attribute value is still empty, default to false
                <span class="cov0" title="0">if entityAttrVal == "" </span><span class="cov0" title="0">{
                        entityAttrVal = falseStr
                        valType = typeBool
                }</span>

                <span class="cov0" title="0">matched, err := makeComparison(entityAttrVal, term.Val, valType, term.Op)

                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("error making comparison %w", err)
                }</span>

                <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

        }

        <span class="cov0" title="0">return true, nil</span>
}

func getTypeFromSchema(class string, attrName string, ruleSchemas []*Schema_t) string <span class="cov0" title="0">{
        for _, ruleSchema := range ruleSchemas </span><span class="cov0" title="0">{

                if ruleSchema.Class == class </span><span class="cov0" title="0">{
                        for _, attrSchema := range ruleSchema.PatternSchema </span><span class="cov0" title="0">{

                                if attrSchema.Attr == attrName </span><span class="cov0" title="0">{

                                        return attrSchema.ValType
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// Returns whether or not the comparison represented by {entityAttrVal, op, termAttrVal} is true
// For example, {7, gt (greater than), 5} is true but {3, gt, 5} is false
func makeComparison(entityAttrVal string, termAttrVal any, valType string, op string) (bool, error) <span class="cov0" title="0">{
        entityAttrValConv, err := convertEntityAttrVal(entityAttrVal, valType)

        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error converting value: %w", err)
        }</span>
        <span class="cov0" title="0">switch op </span>{
        case opEQ:<span class="cov0" title="0">
                return entityAttrValConv == termAttrVal, nil</span>
        case opNE:<span class="cov0" title="0">
                return entityAttrValConv != termAttrVal, nil</span>
        }
        <span class="cov0" title="0">orderedTypes := map[string]bool{typeInt: true, typeFloat: true, typeTS: true, typeStr: true}
        if !orderedTypes[valType] </span><span class="cov0" title="0">{
                return false, errors.New("not an ordered type")
        }</span>
        <span class="cov0" title="0">var result int8
        var match bool
        switch op </span>{
        case opLT:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == -1)</span>
        case opLE:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == -1) || (result == 0)</span>
        case opGT:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == 1)</span>
        case opGE:<span class="cov0" title="0">
                result, err = compare(entityAttrValConv, termAttrVal)
                match = (result == 1) || (result == 0)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error making comparison %w", err)
        }</span>
        <span class="cov0" title="0">return match, nil</span>
}

// Converts the string entityAttrVal to its schema-provided type
func convertEntityAttrVal(entityAttrVal string, valType string) (any, error) <span class="cov0" title="0">{

        var entityAttrValConv any
        var err error
        switch valType </span>{
        case typeBool:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.ParseBool(entityAttrVal)</span>
        case typeInt:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.Atoi(entityAttrVal)</span>
        case typeFloat:<span class="cov0" title="0">
                entityAttrValConv, err = strconv.ParseFloat(entityAttrVal, 64)</span>
        case typeStr, typeEnum:<span class="cov0" title="0">
                entityAttrValConv = entityAttrVal</span>
        case typeTS:<span class="cov0" title="0">
                entityAttrValConv, err = time.Parse(timeLayout, entityAttrVal)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return entityAttrValConv, nil</span>
}

// The compare function returns:
// 0 if a == b,
// -1 if a &lt; b, or
// 1 if a &gt; b
func compare(a any, b any) (int8, error) <span class="cov0" title="0">{
        if a == b </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">var lessThan bool
        switch a.(type) </span>{
        case int:<span class="cov0" title="0">
                if a.(int) &lt; b.(int) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
        case float64:<span class="cov0" title="0">
                if a.(float64) &lt; b.(float64) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
        case string:<span class="cov0" title="0">
                if a.(string) &lt; b.(string) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
        case time.Time:<span class="cov0" title="0">
                if a.(time.Time).Before(b.(time.Time)) </span><span class="cov0" title="0">{
                        lessThan = true
                }</span>
        default:<span class="cov0" title="0">
                return -2, errors.New("invalid type")</span>
        }
        <span class="cov0" title="0">if lessThan </span><span class="cov0" title="0">{
                return -1, nil
        }</span> else<span class="cov0" title="0"> {
                return 1, nil
        }</span>
}
func incrementStatsSchemaCounterNChecked(class string, schema []*Schema_t) <span class="cov0" title="0">{

        for _, ruleSchema := range schema </span><span class="cov0" title="0">{

                if ruleSchema.Class == class </span><span class="cov0" title="0">{

                        ruleSchema.NChecked++
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
This file contains verifyRuleSchema(), verifyRuleSet(), doReferentialChecks() and verifyEntity(),
and their helper functions
*/

package crux

import (
        "fmt"
        "reflect"
        "regexp"
        "time"
)

const (
        step       = "step"
        stepFailed = "stepfailed"
        start      = "START"
        nextStep   = "nextstep"
        done       = "done"

        cruxIDRegExp = `^[a-z][a-z0-9_]*$`
)

var validTypes = map[string]bool{
        typeBool: true, typeInt: true, typeFloat: true, typeStr: true, typeEnum: true, typeTS: true,
}

var validOps = map[string]bool{
        opEQ: true, opNE: true, opLT: true, opLE: true, opGT: true, opGE: true,
}

type CruxError struct {
        Keyword   string `json:"keyword"`
        FieldName string `json:"fieldName"`
        Messages  string `json:"messages"`
        Vals      string `json:"vals,omitempty"`
}

// Error returns the error message string
func (e CruxError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s: %s: %s", e.Keyword, e.FieldName, e.Vals, e.Messages)
}</span>

// Parameters
// rs RuleSchema: the RuleSchema to be verified
// isWF bool: true if the RuleSchema applies to a workflow, otherwise false
func VerifyRuleSchema(rschema []*Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        for _, rs := range rschema </span><span class="cov0" title="0">{

                if len(rs.Class) == 0 </span><span class="cov0" title="0">{
                        err := CruxError{Keyword: "Empty", FieldName: "class", Messages: "schema class is an empty string"} //fmt.Errorf("schema class is an empty string")
                        errs = append(errs, err)
                }</span>
                <span class="cov0" title="0">if err := VerifyPatternSchema(*rs, isWF); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err...)
                }</span>
                <span class="cov0" title="0">if err := VerifyActionSchema(*rs, isWF); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err...)
                }</span>
        }
        <span class="cov0" title="0">return errs</span>
}

func VerifyPatternSchema(rs Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        if len(rs.PatternSchema) == 0 </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "Empty", FieldName: "patternSchema", Messages: "pattern-schema is empty"} //fmt.Errorf("pattern-schema for %v is empty", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">re := regexp.MustCompile(cruxIDRegExp)
        // Bools needed for workflows only
        stepFound, stepFailedFound := false, false

        for i, attrSchema := range rs.PatternSchema </span><span class="cov0" title="0">{
                i++
                if _, exists := validTypes[attrSchema.ValType]; exists </span>{<span class="cov0" title="0">

                }</span> else<span class="cov0" title="0"> {
                        fieldName := fmt.Sprintf("patternSchema[%d].ValType", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: attrSchema.ValType, Messages: "not a valid value-type"} //fmt.Errorf("%v is not a valid value-type", attrSchema.ValType)
                        errs = append(errs, err)
                }</span>

                <span class="cov0" title="0">if !re.MatchString(attrSchema.Attr) </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("patternSchema[%d].attr", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: attrSchema.Attr, Messages: "attribute name is not a valid CruxID"} //fmt.Errorf("attribute name %v is not a valid CruxID", attrSchema.Attr)
                        errs = append(errs, err)
                }</span> else<span class="cov0" title="0"> if attrSchema.ValType == typeEnum &amp;&amp; len(attrSchema.EnumVals) == 0 </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("patternSchema[%d].Vals", i)
                        err := CruxError{Keyword: "Empty", FieldName: fieldName, Messages: "no valid values for enum"} //fmt.Errorf("no valid values for enum %v", attrSchema.Attr)
                        errs = append(errs, err)
                }</span>
                <span class="cov0" title="0">for val := range attrSchema.EnumVals </span><span class="cov0" title="0">{
                        if !re.MatchString(val) &amp;&amp; val != start </span><span class="cov0" title="0">{
                                fieldName := fmt.Sprintf("patternSchema[%d].Vals", i)
                                err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: val, Messages: "enum value is not a valid CruxID"} //fmt.Errorf("enum value %v is not a valid CruxID", val)
                                errs = append(errs, err)
                        }</span>
                }

                // Workflows only
                <span class="cov0" title="0">if attrSchema.Attr == step &amp;&amp; attrSchema.ValType == typeEnum </span><span class="cov0" title="0">{
                        stepFound = true
                }</span>

                <span class="cov0" title="0">if isWF &amp;&amp; attrSchema.Attr == step &amp;&amp; attrSchema.EnumVals[start] != struct{}{} </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("patternSchema[%d].Vals", i)
                        err := CruxError{Keyword: "NotAllowed", FieldName: fieldName, Vals: "Start", Messages: "workflow schema doesn't allow step=START"} //fmt.Errorf("workflow schema for %v doesn't allow step=START", rs.Class)
                        errs = append(errs, err)
                }</span>
                <span class="cov0" title="0">if attrSchema.Attr == stepFailed &amp;&amp; attrSchema.ValType == typeBool </span><span class="cov0" title="0">{
                        stepFailedFound = true
                }</span>
        }

        // Workflows only
        <span class="cov0" title="0">if isWF &amp;&amp; (!stepFound || !stepFailedFound) </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "Required", FieldName: "attr", Vals: "step/stepfailed", Messages: "necessary attributes aNovant in schema"} //fmt.Errorf("necessary workflow attributes aNovant in schema for class %v", rs.Class)
                errs = append(errs, err)
        }</span>

        <span class="cov0" title="0">return errs</span>

}

func VerifyActionSchema(rs Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        re := regexp.MustCompile(cruxIDRegExp)
        if len(rs.ActionSchema.Tasks) == 0 &amp;&amp; len(rs.ActionSchema.Properties) == 0 </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "Empty", FieldName: "Tasks/Properties", Messages: "both tasks and properties are empty in schema"} //fmt.Errorf("both tasks and properties are empty in schema for class %v", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">for i, task := range rs.ActionSchema.Tasks </span><span class="cov0" title="0">{
                i++
                if !re.MatchString(task) </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("actionSchema.Tasks[%d]", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: task, Messages: "task is not a valid CruxID"} // fmt.Errorf("task %v is not a valid CruxID", task)
                        errs = append(errs, err)
                }</span>
        }

        // Workflows only

        <span class="cov0" title="0">if isWF &amp;&amp; len(rs.ActionSchema.Properties) != 2 </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "NotAllowed", FieldName: "properties", Messages: "contain exactly two properties"} // //fmt.Errorf("action-schema for %v does not contain exactly two properties", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">nextStepFound, doneFound := false, false

        for i, propName := range rs.ActionSchema.Properties </span><span class="cov0" title="0">{
                i++
                if !re.MatchString(propName) </span><span class="cov0" title="0">{
                        fieldName := fmt.Sprintf("actionSchema.Properties[%d]", i)
                        err := CruxError{Keyword: "Invalid", FieldName: fieldName, Vals: propName, Messages: "property name is not a valid CruxID"} //fmt.Errorf("property name %v is not a valid CruxID", propName)
                        errs = append(errs, err)
                }</span> else<span class="cov0" title="0"> if propName == nextStep </span><span class="cov0" title="0">{
                        nextStepFound = true
                }</span> else<span class="cov0" title="0"> if propName == done </span><span class="cov0" title="0">{
                        doneFound = true
                }</span>
        }

        // Workflows only
        <span class="cov0" title="0">if isWF &amp;&amp; (!nextStepFound || !doneFound) </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "NotAllowed", FieldName: "properties", Messages: "does not contain both the properties 'nextstep' and 'done'"} // fmt.Errorf("action-schema for %v does not contain both the properties 'nextstep' and 'done'", rs.Class)
                errs = append(errs, err)
        }</span>

        <span class="cov0" title="0">if isWF &amp;&amp; !reflect.DeepEqual(getTasksMapForWF(rs.ActionSchema.Tasks), getStepAttrVals(rs)) </span><span class="cov0" title="0">{
                err := CruxError{Keyword: "NotAllowed", FieldName: "task", Messages: "action-schema tasks are not the same as valid values for 'step' in pattern-schema"} // fmt.Errorf("action-schema tasks for %v are not the same as valid values for 'step' in pattern-schema", rs.Class)
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">return errs</span>
}

func getTasksMapForWF(tasks []string) map[string]struct{} <span class="cov0" title="0">{
        tm := map[string]struct{}{}
        for _, t := range tasks </span><span class="cov0" title="0">{
                tm[t] = struct{}{}
        }</span>
        // To allow comparison with the set of valid values for the 'step' attribute, which includes "START"
        // tm[start] = struct{}{}

        <span class="cov0" title="0">return tm</span>
}

func getStepAttrVals(rs Schema_t) map[string]struct{} <span class="cov0" title="0">{

        for _, ps := range rs.PatternSchema </span><span class="cov0" title="0">{
                if ps.Attr == step </span><span class="cov0" title="0">{

                        return ps.EnumVals
                }</span>
        }
        <span class="cov0" title="0">return nil</span>

}

// Parameters
// rs RuleSet: the RuleSet to be verified
// isWF bool: true if the RuleSet is a workflow, otherwise false
func verifyRuleSet(entiry Entity, rs *Ruleset_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        schema, err := getSchema(entiry, entiry.class)

        if err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>
        <span class="cov0" title="0">if err := VerifyRulePatterns(rs, schema, isWF); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err...)
        }</span>
        <span class="cov0" title="0">if err := VerifyRuleActions(rs, schema, isWF); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err...)
        }</span>

        <span class="cov0" title="0">return errs</span>
}

func VerifyRulePatterns(ruleset *Ruleset_t, schema *Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        //for _, ruleset := range ruleSets {
        for _, rule := range ruleset.Rules </span><span class="cov0" title="0">{

                for _, term := range rule.RulePatterns </span><span class="cov0" title="0">{

                        valType := getType(schema, term.Attr)

                        if valType == "" </span><span class="cov0" title="0">{
                                // If the attribute name is not in the pattern-schema, we check if it's a task "tag"
                                // by checking for its presence in the action-schema

                                if !isStringInArray(term.Attr, schema.ActionSchema.Tasks) </span><span class="cov0" title="0">{
                                        err := CruxError{Keyword: "NotExist", FieldName: "attr", Vals: term.Attr, Messages: "attribute does not exist in schema"} // fmt.Errorf("attribute does not exist in schema: %v", term.Attr)
                                        errs = append(errs, err)
                                }</span>
                                // If it is a tag, the value type is set to bool
                                <span class="cov0" title="0">valType = typeStr</span>
                        }
                        <span class="cov0" title="0">if !verifyType(term.Val, valType) </span><span class="cov0" title="0">{

                                err := CruxError{Keyword: "NotMatch", FieldName: "val", Messages: "value of this attribute does not match schema"} // fmt.Errorf("value of this attribute does not match schema type: %v", term.Attr)
                                errs = append(errs, err)
                        }</span>
                        <span class="cov0" title="0">if !validOps[term.Op] </span><span class="cov0" title="0">{

                                err := CruxError{Keyword: "Invalid", FieldName: "op", Vals: term.Op, Messages: "invalid operation in rule"} // fmt.Errorf("invalid operation in rule: %v", term.Op)
                                errs = append(errs, err)
                        }</span>
                }
                // Workflows only
                <span class="cov0" title="0">if isWF </span><span class="cov0" title="0">{
                        stepFound := false
                        for _, term := range rule.RulePatterns </span><span class="cov0" title="0">{
                                if term.Attr == step </span><span class="cov0" title="0">{

                                        stepFound = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !stepFound </span><span class="cov0" title="0">{

                                err := CruxError{Keyword: "Required", FieldName: "attr", Messages: "required one 'step' attribute in a rule in workflow"} // fmt.Errorf("no 'step' attribute found in a rule in workflow %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}

func getSchema(entity Entity, class string) (*Schema_t, error) <span class="cov0" title="0">{
        ruleSchemas, _ := retriveRuleSchemasAndRuleSetsFromCache(entity.realm, entity.app, entity.class, entity.slice)

        if len(ruleSchemas) &gt; 0 </span><span class="cov0" title="0">{

                for _, s := range ruleSchemas </span><span class="cov0" title="0">{

                        if class == s.Class </span><span class="cov0" title="0">{
                                return s, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no schema found for class %v", class)</span>
}

func getType(rs *Schema_t, name string) string <span class="cov0" title="0">{
        for _, as := range rs.PatternSchema </span><span class="cov0" title="0">{
                if as.Attr == name </span><span class="cov0" title="0">{
                        return as.ValType
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func isStringInArray(s string, arr []string) bool <span class="cov0" title="0">{
        for _, a := range arr </span><span class="cov0" title="0">{

                if a == s </span><span class="cov0" title="0">{

                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Returns whether or not the type of "val" is the same as "valType"
func verifyType(val any, valType string) bool <span class="cov0" title="0">{

        var ok bool
        switch valType </span>{
        case typeBool:<span class="cov0" title="0">
                _, ok = val.(bool)</span>
        case typeInt:<span class="cov0" title="0">
                _, ok = val.(int)</span>
        case typeFloat:<span class="cov0" title="0">
                _, ok = val.(float64)</span>
        case typeStr:<span class="cov0" title="0">

                _, ok = val.(string)</span>
        case typeEnum:<span class="cov0" title="0">

                _, ok = val.(string)</span>
        case typeTS:<span class="cov0" title="0">
                s, _ := val.(string)
                _, err := time.Parse(timeLayout, s)
                ok = (err == nil)</span>
        }

        <span class="cov0" title="0">return ok</span>
}

func VerifyRuleActions(ruleset *Ruleset_t, schema *Schema_t, isWF bool) []error <span class="cov0" title="0">{
        var errs []error
        //for _, ruleset := range ruleSets {
        for _, rule := range ruleset.Rules </span><span class="cov0" title="0">{
                for _, t := range rule.RuleActions.Task </span><span class="cov0" title="0">{

                        doRet := rule.RuleActions.DoReturn
                        doExit := rule.RuleActions.DoExit

                        found := false

                        if doRet &amp;&amp; doExit </span><span class="cov0" title="0">{
                                err := CruxError{Keyword: "Required", FieldName: "rule", Messages: "required one of RETURN or EXIT"} // fmt.Errorf("there is a rule with both the RETURN and EXIT instructions in ruleset %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                        <span class="cov0" title="0">if isStringInArray(t, schema.ActionSchema.Tasks) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                err := CruxError{Keyword: "NotExist", FieldName: "task", Messages: "task not found in any action-schema"} // fmt.Errorf("task %v not found in any action-schema", t)
                                errs = append(errs, err)
                        }</span>
                }

                <span class="cov0" title="0">for propName := range rule.RuleActions.Properties </span><span class="cov0" title="0">{
                        found := false

                        if isStringInArray(propName, schema.ActionSchema.Properties) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                err := CruxError{Keyword: "        ", FieldName: "properties", Messages: "property name not found in any action-schema"} // fmt.Errorf("property name %v not found in any action-schema", propName)
                                errs = append(errs, err)

                        }</span>
                }

                // Workflows only
                <span class="cov0" title="0">if isWF </span><span class="cov0" title="0">{

                        nsFound, doneFound := areNextStepAndDoneInProps(rule.RuleActions.Properties)
                        if !nsFound &amp;&amp; !doneFound </span><span class="cov0" title="0">{
                                err := CruxError{Keyword: "NotAllowed", FieldName: "rule", Messages: "rule found with neither 'nextstep' nor 'done' in ruleset"} // fmt.Errorf("rule found with neither 'nextstep' nor 'done' in ruleset %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                        <span class="cov0" title="0">if !doneFound &amp;&amp; len(rule.RuleActions.Task) == 0 </span><span class="cov0" title="0">{
                                err := CruxError{Keyword: "NotExist", FieldName: "rule", Messages: "no tasks and no 'done=true' in a rule"} // fmt.Errorf("no tasks and no 'done=true' in a rule in ruleset %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                        <span class="cov0" title="0">currNS := getNextStep(rule.RuleActions.Properties)
                        if len(currNS) &gt; 0 &amp;&amp; !isStringInArray(currNS, rule.RuleActions.Task) </span><span class="cov0" title="0">{
                                err := CruxError{Keyword: "NotExist", FieldName: "tasks", Messages: "`nextstep` value not found in `tasks` in a rule "} // fmt.Errorf("`nextstep` value not found in `tasks` in a rule in ruleset %v", ruleset.SetName)
                                errs = append(errs, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return errs</span>
}

func areNextStepAndDoneInProps(props map[string]string) (bool, bool) <span class="cov0" title="0">{
        nsFound, doneFound := false, false
        for name, val := range props </span><span class="cov0" title="0">{

                if name == nextStep </span><span class="cov0" title="0">{
                        nsFound = true
                }</span>
                <span class="cov0" title="0">if name == done &amp;&amp; val == trueStr </span><span class="cov0" title="0">{
                        doneFound = true
                }</span>
        }
        <span class="cov0" title="0">return nsFound, doneFound</span>
}

func getNextStep(props map[string]string) string <span class="cov0" title="0">{
        for name, val := range props </span><span class="cov0" title="0">{
                if name == nextStep </span><span class="cov0" title="0">{
                        return val
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func doReferentialChecks(e Entity) (bool, error) <span class="cov0" title="0">{
        _, ruleSets := retriveRuleSchemasAndRuleSetsFromCache(e.realm, e.app, e.class, e.slice)

        for _, ruleset := range ruleSets </span><span class="cov0" title="0">{
                for _, rule := range ruleset.Rules </span><span class="cov0" title="0">{

                        if rule.RuleActions.ThenCall != "" || rule.RuleActions.ElseCall != "" </span><span class="cov0" title="0">{

                                return true, nil
                        }</span>

                }
        }
        <span class="cov0" title="0">return true, nil</span>
}

func verifyEntity(e Entity) (bool, error) <span class="cov0" title="0">{
        rs, err := getSchema(e, e.class)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">for attrName, attrVal := range e.attrs </span><span class="cov0" title="0">{

                t := getType(rs, attrName)
                if t == "" </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("schema does not contain attribute %v", attrName)
                }</span>
                <span class="cov0" title="0">_, err := convertEntityAttrVal(attrVal, t)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("attribute %v in entity has value of wrong type", attrName)
                }</span>
        }
        <span class="cov0" title="0">if len(e.attrs) != len(rs.PatternSchema) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("entity does not contain all the attributes in its pattern-schema")
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package config

import (
        "github.com/gin-gonic/gin"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/server"
        "github.com/remiges-tech/crux/types"
)

func ConfigGet(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        l := s.LogHarbour
        l.Debug0().Log("Starting execution of ConfigGet()")

        // userID, err := server.ExtractUserNameFromJwt(c)
        // if err != nil {
        //         l.Info().Log("unable to extract userID from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ERRCode_Token_Data_Missing))
        //         return
        // }

        // realmName, err := server.ExtractRealmFromJwt(c)
        // if err != nil {
        //         l.Info().Log("unable to extract realm from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ERRCode_Token_Data_Missing))
        //         return
        // }

        reqCaps := []string{"root"}
        isCapable, _ := server.Authz_check(types.OpReq{
                User:      userID,
                CapNeeded: reqCaps,
        }, false)

        if !isCapable </span><span class="cov0" title="0">{
                l.Info().LogActivity("Unauthorized user:", userID)
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Unauthorized, server.ErrCode_Unauthorized))
                return
        }</span>

        <span class="cov8" title="1">query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                l.Debug0().Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_Internal))
                return
        }</span>
        <span class="cov8" title="1">configs, err := query.ConfigGet(c, realmName)
        if err != nil </span><span class="cov0" title="0">{
                l.Info().Error(err).Log("Error while getting config list")
                errmsg := db.HandleDatabaseError(err)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{errmsg}))
                return
        }</span>
        <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: configs, Messages: nil})
        l.Debug0().Log("Finished execution of ConfigGet()")</span>

}
</pre>
		
		<pre class="file" id="file23" style="display: none">package config

import (
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/remiges-tech/alya/service"
        "github.com/remiges-tech/alya/wscutils"
        "github.com/remiges-tech/crux/db"
        "github.com/remiges-tech/crux/db/sqlc-gen"
        "github.com/remiges-tech/crux/server"
        "github.com/remiges-tech/crux/types"
)

type ConfigSetReq struct {
        Attr string `json:"attr" validate:"required,alpha,lt=15"`
        Val  string `json:"val" validate:"required"`

        Slice int32  `json:"slice" validate:"required,gt=0,lt=15"`
        Descr string `json:"descr,omitempty" `
}

func ConfigSet(c *gin.Context, s *service.Service) <span class="cov8" title="1">{
        l := s.LogHarbour
        l.Debug0().Log("Starting execution of ConfigSet()")

        // userID, err := server.ExtractUserNameFromJwt(c)
        // if err != nil {
        //         l.Info().Log("unable to extract userID from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ERRCode_Token_Data_Missing))
        //         return
        // }

        // realmName, err := server.ExtractRealmFromJwt(c)
        // if err != nil {
        //         l.Info().Log("unable to extract realm from token")
        //         wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Missing, server.ERRCode_Token_Data_Missing))
        //         return
        // }

        reqCaps := []string{"root"}
        isCapable, _ := server.Authz_check(types.OpReq{
                User:      userID,
                CapNeeded: reqCaps,
        }, false)

        if !isCapable </span><span class="cov0" title="0">{
                l.Info().LogActivity("Unauthorized user:", userID)
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_Unauthorized, server.ErrCode_Unauthorized))
                return
        }</span>

        <span class="cov8" title="1">var req ConfigSetReq

        err := wscutils.BindJSON(c, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                l.Error(err).Log("Error Unmarshalling Query parameters to struct:")
                return
        }</span>

        // Validate request
        <span class="cov8" title="1">validationErrors := wscutils.WscValidate(req, func(err validator.FieldError) []string </span><span class="cov8" title="1">{ return []string{} }</span>)
        <span class="cov8" title="1">if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                l.Debug0().LogDebug("validation errors", validationErrors)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, validationErrors))
                return
        }</span>

        <span class="cov8" title="1">query, ok := s.Dependencies["queries"].(*sqlc.Queries)
        if !ok </span><span class="cov0" title="0">{
                l.Debug0().Log("Error while getting query instance from service Dependencies")
                wscutils.SendErrorResponse(c, wscutils.NewErrorResponse(server.MsgId_InternalErr, server.ErrCode_Internal))
                return
        }</span>

        <span class="cov8" title="1">err = query.ConfigSet(c, sqlc.ConfigSetParams{
                Realm: realmName,
                Slice: req.Slice,
                Name:  strings.ToUpper(req.Attr),
                Descr: req.Descr,
                Val:   pgtype.Text{String: req.Val, Valid: true},
                Setby: userID,
        })
        if err != nil </span><span class="cov8" title="1">{
                l.Info().Error(err).Log("Error while creating config")
                errmsg := db.HandleDatabaseError(err)
                wscutils.SendErrorResponse(c, wscutils.NewResponse(wscutils.ErrorStatus, nil, []wscutils.ErrorMessage{errmsg}))
                return
        }</span>
        <span class="cov8" title="1">wscutils.SendSuccessResponse(c, &amp;wscutils.Response{Status: wscutils.SuccessStatus, Data: nil, Messages: nil})
        l.Debug0().Log("Finished execution of ConfigSet()")</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package server

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "os"
        "slices"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/golang-jwt/jwt/v4"
        "github.com/remiges-tech/alya/router"
        "github.com/remiges-tech/alya/wscutils"
        crux "github.com/remiges-tech/crux/matching-engine"
        "github.com/remiges-tech/crux/types"
)

// CommonValidation is a generic function which setup standard validation utilizing
// validator package and Maps the errorVals based on the map parameter and
// return []errorVals
func CommonValidation(err validator.FieldError) []string <span class="cov0" title="0">{
        var vals []string
        switch err.Tag() </span>{
        case "required":<span class="cov0" title="0">
                vals = append(vals, "not_provided")</span>
        case "alpha":<span class="cov0" title="0">
                vals = append(vals, "only_alphabets_are_allowed")</span>
        case "gt":<span class="cov0" title="0">
                vals = append(vals, "must_be_greater_than_zero")</span>
        default:<span class="cov0" title="0">
                vals = append(vals, "not_valid_input")</span>
        }
        <span class="cov0" title="0">return vals</span>
}

func MarshalJson(data any) []byte <span class="cov0" title="0">{
        jsonData, err := json.Marshal(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error marshaling")
        }</span>
        <span class="cov0" title="0">return jsonData</span>
}

func ReadJsonFromFile(filepath string) ([]byte, error) <span class="cov0" title="0">{
        // var err error
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("testFile path is not exist")
        }</span>
        <span class="cov0" title="0">defer file.Close()
        jsonData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return jsonData, nil</span>
}

// to check given string is nil or not
func IsStringEmpty(s *string) bool <span class="cov0" title="0">{
        return s == nil || strings.TrimSpace(*s) == ""
}</span>

// to check if the user has "ruleset" rights for the given app
func HasRulesetRights(app string) bool <span class="cov0" title="0">{
        userRights := GetWorkflowsByRulesetRights()
        return slices.Contains(userRights, app)
}</span>

// to get workflows for all apps for which the user has "ruleset" rights
func GetWorkflowsByRulesetRights() []string <span class="cov0" title="0">{
        return []string{"retailBANK", "nedbank"}
}</span>

func Authz_check(op types.OpReq, trace bool) (bool, []string) <span class="cov8" title="1">{
        caplist := op.CapNeeded
        return true, caplist
}</span>

// ExtractClaimFromJwt: this will extract the provided singleClaimName as key from the jwt token and return its value as a string
func ExtractClaimFromJwt(c *gin.Context, singleClaimName string) (string, error) <span class="cov0" title="0">{
        tokenString, err := router.ExtractToken(c.GetHeader("Authorization"))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token payload")
        }</span>
        <span class="cov0" title="0">var name string
        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token payload")
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                name = fmt.Sprint(claims[singleClaimName])
        }</span>

        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token payload")
        }</span>

        <span class="cov0" title="0">return name, nil</span>
}

func ExtractRealmFromJwt(c *gin.Context) (string, error) <span class="cov0" title="0">{
        str, err := ExtractClaimFromJwt(c, "iss")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">parts := strings.Split(str, "/realms/")
        realm := parts[1]
        return realm, nil</span>
}

func ExtractUserNameFromJwt(c *gin.Context) (string, error) <span class="cov0" title="0">{
        return ExtractClaimFromJwt(c, "preferred_username")
}</span>

func HandleCruxError(errs []error) []wscutils.ErrorMessage <span class="cov0" title="0">{
        var validationErrors []wscutils.ErrorMessage
        for _, err := range errs </span><span class="cov0" title="0">{
                var cruxErr crux.CruxError
                fmt.Println("validationErrors", err)

                if errors.As(err, &amp;cruxErr) </span><span class="cov0" title="0">{
                        switch cruxErr.Keyword </span>{
                        case "Empty":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Empty, ErrCode_Empty, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "Invalid":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid, ErrCode_Invalid, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "NotAllowed":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid, ErrCode_Invalid, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "Required":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid_Request, ErrCode_RequiredOneOf, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "NotExist":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid, ErrCode_Does_Not_Contain_Both_Properties_Nextstep_And_Done, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        case "NotMatch":<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid, ErrCode_Does_Not_Contain_Both_Properties_Nextstep_And_Done, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        default:<span class="cov0" title="0">
                                vErr := wscutils.BuildErrorMessage(MsgId_Invalid_Request, ErrCode_InvalidRequest, &amp;cruxErr.FieldName, cruxErr.Vals)
                                validationErrors = append(validationErrors, vErr)</span>
                        }
                }

        }
        <span class="cov0" title="0">return validationErrors</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package testutils

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"

        "github.com/remiges-tech/alya/wscutils"
)

func MarshalJson(data any) []byte <span class="cov8" title="1">{
        jsonData, err := json.Marshal(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error marshaling")
        }</span>
        <span class="cov8" title="1">return jsonData</span>
}

func ReadJsonFromFile(filepath string) ([]byte, error) <span class="cov8" title="1">{
        // var err error
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("testFile path is not exist")
        }</span>
        <span class="cov8" title="1">defer file.Close()
        jsonData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return jsonData, nil</span>
}

type TestCasesStruct struct {
        Name             string
        RequestPayload   wscutils.Request
        ExpectedHttpCode int
        TestJsonFile     string
        ExpectedResult   *wscutils.Response
        Url              string
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package types

const (
        DevEnv           Environment = "dev_env"
        ProdEnv          Environment = "prod_env"
        UATEnv           Environment = "uat_env"
        RECORD_NOT_EXIST             = "record_does_not_exist"
        Op_FAILED                    = "Op_failed"
)

var APP, SLICE, CLASS, NAME string = "App", "Slice", "Class", "Name"

type Environment string

func (env Environment) IsValid() bool <span class="cov0" title="0">{
        switch env </span>{
        case DevEnv, ProdEnv, UATEnv:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

type OpReq struct {
        User      string   `json:"user"`
        CapNeeded []string `json:"capNeeded"`
        Scope     Scope    `json:"scope"`
        Limit     Limit    `json:"limit"`
}

type Scope map[string]interface{}
type Limit map[string]interface{}

type QualifiedCap struct {
        Id    string `json:"id"`
        Cap   string `json:"cap"`
        Scope Scope  `json:"scope"`
        Limit Limit  `json:"limit"`
}

type Capabilities struct {
        Name          string         `json:"name"` //either user name or group name
        QualifiedCaps []QualifiedCap `json:"qualifiedCaps"`
}

type Attribute struct {
        Name      string   `json:"name" validate:"required"`
        ShortDesc string   `json:"shortdesc" validate:"required"`
        LongDesc  string   `json:"longdesc" validate:"required"`
        ValType   string   `json:"valtype" validate:"required"`
        Vals      []string `json:"vals,omitempty"`
        Enumdesc  []string `json:"enumdesc,omitempty"`
        ValMax    *int32   `json:"valmax,omitempty"`
        ValMin    *int32   `json:"valmin,omitempty"`
        LenMax    *int32   `json:"lenmax,omitempty"`
        LenMin    *int32   `json:"lenmin,omitempty"`
}

type PatternSchema struct {
        Class string      `json:"class" validate:"required,lowercase"`
        Attr  []Attribute `json:"attr" validate:"required,dive"`
}

type ActionSchema struct {
        Class      string   `json:"class" validate:"required,lowercase"`
        Tasks      []string `json:"tasks" validate:"required"`
        Properties []string `json:"properties" validate:"required"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
